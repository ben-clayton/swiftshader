// Copyright 2019 The SwiftShader Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated with protocol_gen.go -- do not edit this file.
//   go run scripts/protocol_gen/protocol_gen.go

#ifndef dap_protocol_h
#define dap_protocol_h

#include "optional.h"
#include "typeinfo.h"
#include "typeof.h"
#include "variant.h"

#include <string>
#include <type_traits>
#include <vector>

namespace dap {

struct Request {};
struct Response {};
struct Event {};

namespace detail {

template <typename T>
struct Traits {
  static constexpr bool isRequest = std::is_base_of<dap::Request, T>::value;
  static constexpr bool isResponse = std::is_base_of<dap::Response, T>::value;
  static constexpr bool isEvent = std::is_base_of<dap::Event, T>::value;
};

}  // namespace detail

#ifndef DAP_PROTOCOL_STRUCT_TYPEINFO
#define DAP_PROTOCOL_STRUCT_TYPEINFO(STRUCT, NAME, ...) \
  DAP_DECLARE_STRUCT_TYPEINFO(STRUCT)
#define UNDEF_DAP_PROTOCOL_STRUCT_TYPEINFO 1
#endif  // DAP_PROTOCOL_STRUCT_TYPEINFO
// Response to 'attach' request. This is just an acknowledgement, so no body
// field is required.
struct AttachResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(AttachResponse, "");

// The attach request is sent from the client to the debug adapter to attach to
// a debuggee that is already running. Since attaching is debugger/runtime
// specific, the arguments for this request are not part of this specification.
struct AttachRequest : public Request {
  using Response = AttachResponse;
  // Optional data from the previous, restarted session.
  // The data is sent as the 'restart' attribute of the 'terminated' event.
  // The client should leave the data intact.
  optional<variant<array<any>,
                   boolean,
                   integer,
                   null,
                   number,
                   map<string, any>,
                   string>>
      restart;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(AttachRequest,
                             "attach",
                             DAP_FIELD(restart, "__restart"));

// Arguments for 'attach' request. Additional attributes are implementation
// specific.
struct AttachRequestArguments {
  // Optional data from the previous, restarted session.
  // The data is sent as the 'restart' attribute of the 'terminated' event.
  // The client should leave the data intact.
  optional<variant<array<any>,
                   boolean,
                   integer,
                   null,
                   number,
                   map<string, any>,
                   string>>
      restart;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(AttachRequestArguments,
                             "",
                             DAP_FIELD(restart, "__restart"));

// Names of checksum algorithms that may be supported by a debug adapter.
struct ChecksumAlgorithm {};

DAP_PROTOCOL_STRUCT_TYPEINFO(ChecksumAlgorithm, "");

// The checksum of an item calculated by the specified algorithm.
struct Checksum {
  // The algorithm used to calculate this checksum.
  ChecksumAlgorithm algorithm;
  // Value of the checksum.
  string checksum;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(Checksum,
                             "",
                             DAP_FIELD(algorithm, "algorithm"),
                             DAP_FIELD(checksum, "checksum"));

// A Source is a descriptor for source code. It is returned from the debug
// adapter as part of a StackFrame and it is used by clients when specifying
// breakpoints.
struct Source {
  // Optional data that a debug adapter might want to loop through the client.
  // The client should leave the data intact and persist it across sessions. The
  // client should not interpret the data.
  optional<variant<array<any>,
                   boolean,
                   integer,
                   null,
                   number,
                   map<string, any>,
                   string>>
      adapterData;
  // The checksums associated with this file.
  optional<array<Checksum>> checksums;
  // The short name of the source. Every source returned from the debug adapter
  // has a name. When sending a source to the debug adapter this name is
  // optional.
  optional<string> name;
  // The (optional) origin of this source: possible values 'internal module',
  // 'inlined content from source map', etc.
  optional<string> origin;
  // The path of the source to be shown in the UI. It is only used to locate and
  // load the content of the source if no sourceReference is specified (or its
  // value is 0).
  optional<string> path;
  // An optional hint for how to present the source in the UI. A value of
  // 'deemphasize' can be used to indicate that the source is not available or
  // that it is skipped on stepping.
  //
  // Must be one of the following enumeration values:
  // 'normal', 'emphasize', 'deemphasize'
  optional<string> presentationHint;
  // If sourceReference > 0 the contents of the source must be retrieved through
  // the SourceRequest (even if a path is specified). A sourceReference is only
  // valid for a session, so it must not be used to persist a source. The value
  // should be less than or equal to 2147483647 (2^31 - 1).
  optional<integer> sourceReference;
  // An optional list of sources that are related to this source. These may be
  // the source that generated this source.
  optional<array<Source>> sources;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(Source,
                             "",
                             DAP_FIELD(adapterData, "adapterData"),
                             DAP_FIELD(checksums, "checksums"),
                             DAP_FIELD(name, "name"),
                             DAP_FIELD(origin, "origin"),
                             DAP_FIELD(path, "path"),
                             DAP_FIELD(presentationHint, "presentationHint"),
                             DAP_FIELD(sourceReference, "sourceReference"),
                             DAP_FIELD(sources, "sources"));

// Information about a Breakpoint created in setBreakpoints or
// setFunctionBreakpoints.
struct Breakpoint {
  // An optional start column of the actual range covered by the breakpoint.
  optional<integer> column;
  // An optional end column of the actual range covered by the breakpoint. If no
  // end line is given, then the end column is assumed to be in the start line.
  optional<integer> endColumn;
  // An optional end line of the actual range covered by the breakpoint.
  optional<integer> endLine;
  // An optional identifier for the breakpoint. It is needed if breakpoint
  // events are used to update or remove breakpoints.
  optional<integer> id;
  // The start line of the actual range covered by the breakpoint.
  optional<integer> line;
  // An optional message about the state of the breakpoint. This is shown to the
  // user and can be used to explain why a breakpoint could not be verified.
  optional<string> message;
  // The source where the breakpoint is located.
  optional<Source> source;
  // If true breakpoint could be set (but not necessarily at the desired
  // location).
  boolean verified;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(Breakpoint,
                             "",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(endColumn, "endColumn"),
                             DAP_FIELD(endLine, "endLine"),
                             DAP_FIELD(id, "id"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(message, "message"),
                             DAP_FIELD(source, "source"),
                             DAP_FIELD(verified, "verified"));

// The event indicates that some information about a breakpoint has changed.
struct BreakpointEvent : public Event {
  // The 'id' attribute is used to find the target breakpoint and the other
  // attributes are used as the new values.
  Breakpoint breakpoint;
  // The reason for the event.
  //
  // May be one of the following enumeration values:
  // 'changed', 'new', 'removed'
  string reason;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(BreakpointEvent,
                             "breakpoint",
                             DAP_FIELD(breakpoint, "breakpoint"),
                             DAP_FIELD(reason, "reason"));

// Properties of a breakpoint location returned from the 'breakpointLocations'
// request.
struct BreakpointLocation {
  // Optional start column of breakpoint location.
  optional<integer> column;
  // Optional end column of breakpoint location if the location covers a range.
  optional<integer> endColumn;
  // Optional end line of breakpoint location if the location covers a range.
  optional<integer> endLine;
  // Start line of breakpoint location.
  integer line;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(BreakpointLocation,
                             "",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(endColumn, "endColumn"),
                             DAP_FIELD(endLine, "endLine"),
                             DAP_FIELD(line, "line"));

// Arguments for 'breakpointLocations' request.
struct BreakpointLocationsArguments {
  // Optional start column of range to search possible breakpoint locations in.
  // If no start column is given, the first column in the start line is assumed.
  optional<integer> column;
  // Optional end column of range to search possible breakpoint locations in. If
  // no end column is given, then it is assumed to be in the last column of the
  // end line.
  optional<integer> endColumn;
  // Optional end line of range to search possible breakpoint locations in. If
  // no end line is given, then the end line is assumed to be the start line.
  optional<integer> endLine;
  // Start line of range to search possible breakpoint locations in. If only the
  // line is specified, the request returns all possible locations in that line.
  integer line;
  // The source location of the breakpoints; either 'source.path' or
  // 'source.reference' must be specified.
  Source source;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(BreakpointLocationsArguments,
                             "",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(endColumn, "endColumn"),
                             DAP_FIELD(endLine, "endLine"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(source, "source"));

// Response to 'breakpointLocations' request.
// Contains possible locations for source breakpoints.
struct BreakpointLocationsResponse : public Response {
  // Sorted set of possible breakpoint locations.
  array<BreakpointLocation> breakpoints;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(BreakpointLocationsResponse,
                             "",
                             DAP_FIELD(breakpoints, "breakpoints"));

// The 'breakpointLocations' request returns all possible locations for source
// breakpoints in a given range.
struct BreakpointLocationsRequest : public Request {
  using Response = BreakpointLocationsResponse;
  // Optional start column of range to search possible breakpoint locations in.
  // If no start column is given, the first column in the start line is assumed.
  optional<integer> column;
  // Optional end column of range to search possible breakpoint locations in. If
  // no end column is given, then it is assumed to be in the last column of the
  // end line.
  optional<integer> endColumn;
  // Optional end line of range to search possible breakpoint locations in. If
  // no end line is given, then the end line is assumed to be the start line.
  optional<integer> endLine;
  // Start line of range to search possible breakpoint locations in. If only the
  // line is specified, the request returns all possible locations in that line.
  integer line;
  // The source location of the breakpoints; either 'source.path' or
  // 'source.reference' must be specified.
  Source source;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(BreakpointLocationsRequest,
                             "breakpointLocations",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(endColumn, "endColumn"),
                             DAP_FIELD(endLine, "endLine"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(source, "source"));

// Arguments for 'cancel' request.
struct CancelArguments {
  // The ID (attribute 'seq') of the request to cancel.
  optional<integer> requestId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(CancelArguments,
                             "",
                             DAP_FIELD(requestId, "requestId"));

// Response to 'cancel' request. This is just an acknowledgement, so no body
// field is required.
struct CancelResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(CancelResponse, "");

// The 'cancel' request is used by the frontend to indicate that it is no longer
// interested in the result produced by a specific request issued earlier. This
// request has a hint characteristic: a debug adapter can only be expected to
// make a 'best effort' in honouring this request but there are no guarantees.
// The 'cancel' request may return an error if it could not cancel an operation
// but a frontend should refrain from presenting this error to end users. A
// frontend client should only call this request if the capability
// 'supportsCancelRequest' is true. The request that got canceled still needs to
// send a response back. This can either be a normal result ('success' attribute
// true) or an error response ('success' attribute false and the 'message' set
// to 'cancelled'). Returning partial results from a cancelled request is
// possible but please note that a frontend client has no generic way for
// detecting that a response is partial or not.
struct CancelRequest : public Request {
  using Response = CancelResponse;
  // The ID (attribute 'seq') of the request to cancel.
  optional<integer> requestId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(CancelRequest,
                             "cancel",
                             DAP_FIELD(requestId, "requestId"));

// A ColumnDescriptor specifies what module attribute to show in a column of the
// ModulesView, how to format it, and what the column's label should be. It is
// only used if the underlying UI actually supports this level of customization.
struct ColumnDescriptor {
  // Name of the attribute rendered in this column.
  string attributeName;
  // Format to use for the rendered values in this column. TBD how the format
  // strings looks like.
  optional<string> format;
  // Header UI label of column.
  string label;
  // Datatype of values in this column.  Defaults to 'string' if not specified.
  //
  // Must be one of the following enumeration values:
  // 'string', 'number', 'boolean', 'unixTimestampUTC'
  optional<string> type;
  // Width of this column in characters (hint only).
  optional<integer> width;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ColumnDescriptor,
                             "",
                             DAP_FIELD(attributeName, "attributeName"),
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(label, "label"),
                             DAP_FIELD(type, "type"),
                             DAP_FIELD(width, "width"));

// An ExceptionBreakpointsFilter is shown in the UI as an option for configuring
// how exceptions are dealt with.
struct ExceptionBreakpointsFilter {
  // Initial value of the filter. If not specified a value 'false' is assumed.
  optional<boolean> def;
  // The internal ID of the filter. This value is passed to the
  // setExceptionBreakpoints request.
  string filter;
  // The name of the filter. This will be shown in the UI.
  string label;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ExceptionBreakpointsFilter,
                             "",
                             DAP_FIELD(def, "default"),
                             DAP_FIELD(filter, "filter"),
                             DAP_FIELD(label, "label"));

// Information about the capabilities of a debug adapter.
struct Capabilities {
  // The set of additional module information exposed by the debug adapter.
  optional<array<ColumnDescriptor>> additionalModuleColumns;
  // The set of characters that should trigger completion in a REPL. If not
  // specified, the UI should assume the '.' character.
  optional<array<string>> completionTriggerCharacters;
  // Available filters or options for the setExceptionBreakpoints request.
  optional<array<ExceptionBreakpointsFilter>> exceptionBreakpointFilters;
  // The debug adapter supports the 'terminateDebuggee' attribute on the
  // 'disconnect' request.
  optional<boolean> supportTerminateDebuggee;
  // Checksum algorithms supported by the debug adapter.
  optional<array<ChecksumAlgorithm>> supportedChecksumAlgorithms;
  // The debug adapter supports the 'breakpointLocations' request.
  optional<boolean> supportsBreakpointLocationsRequest;
  // The debug adapter supports the 'cancel' request.
  optional<boolean> supportsCancelRequest;
  // The debug adapter supports the 'completions' request.
  optional<boolean> supportsCompletionsRequest;
  // The debug adapter supports conditional breakpoints.
  optional<boolean> supportsConditionalBreakpoints;
  // The debug adapter supports the 'configurationDone' request.
  optional<boolean> supportsConfigurationDoneRequest;
  // The debug adapter supports data breakpoints.
  optional<boolean> supportsDataBreakpoints;
  // The debug adapter supports the delayed loading of parts of the stack, which
  // requires that both the 'startFrame' and 'levels' arguments and the
  // 'totalFrames' result of the 'StackTrace' request are supported.
  optional<boolean> supportsDelayedStackTraceLoading;
  // The debug adapter supports the 'disassemble' request.
  optional<boolean> supportsDisassembleRequest;
  // The debug adapter supports a (side effect free) evaluate request for data
  // hovers.
  optional<boolean> supportsEvaluateForHovers;
  // The debug adapter supports the 'exceptionInfo' request.
  optional<boolean> supportsExceptionInfoRequest;
  // The debug adapter supports 'exceptionOptions' on the
  // setExceptionBreakpoints request.
  optional<boolean> supportsExceptionOptions;
  // The debug adapter supports function breakpoints.
  optional<boolean> supportsFunctionBreakpoints;
  // The debug adapter supports the 'gotoTargets' request.
  optional<boolean> supportsGotoTargetsRequest;
  // The debug adapter supports breakpoints that break execution after a
  // specified number of hits.
  optional<boolean> supportsHitConditionalBreakpoints;
  // The debug adapter supports the 'loadedSources' request.
  optional<boolean> supportsLoadedSourcesRequest;
  // The debug adapter supports logpoints by interpreting the 'logMessage'
  // attribute of the SourceBreakpoint.
  optional<boolean> supportsLogPoints;
  // The debug adapter supports the 'modules' request.
  optional<boolean> supportsModulesRequest;
  // The debug adapter supports the 'readMemory' request.
  optional<boolean> supportsReadMemoryRequest;
  // The debug adapter supports restarting a frame.
  optional<boolean> supportsRestartFrame;
  // The debug adapter supports the 'restart' request. In this case a client
  // should not implement 'restart' by terminating and relaunching the adapter
  // but by calling the RestartRequest.
  optional<boolean> supportsRestartRequest;
  // The debug adapter supports the 'setExpression' request.
  optional<boolean> supportsSetExpression;
  // The debug adapter supports setting a variable to a value.
  optional<boolean> supportsSetVariable;
  // The debug adapter supports stepping back via the 'stepBack' and
  // 'reverseContinue' requests.
  optional<boolean> supportsStepBack;
  // The debug adapter supports the 'stepInTargets' request.
  optional<boolean> supportsStepInTargetsRequest;
  // The debug adapter supports the 'terminate' request.
  optional<boolean> supportsTerminateRequest;
  // The debug adapter supports the 'terminateThreads' request.
  optional<boolean> supportsTerminateThreadsRequest;
  // The debug adapter supports a 'format' attribute on the stackTraceRequest,
  // variablesRequest, and evaluateRequest.
  optional<boolean> supportsValueFormattingOptions;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(
    Capabilities,
    "",
    DAP_FIELD(additionalModuleColumns, "additionalModuleColumns"),
    DAP_FIELD(completionTriggerCharacters, "completionTriggerCharacters"),
    DAP_FIELD(exceptionBreakpointFilters, "exceptionBreakpointFilters"),
    DAP_FIELD(supportTerminateDebuggee, "supportTerminateDebuggee"),
    DAP_FIELD(supportedChecksumAlgorithms, "supportedChecksumAlgorithms"),
    DAP_FIELD(supportsBreakpointLocationsRequest,
              "supportsBreakpointLocationsRequest"),
    DAP_FIELD(supportsCancelRequest, "supportsCancelRequest"),
    DAP_FIELD(supportsCompletionsRequest, "supportsCompletionsRequest"),
    DAP_FIELD(supportsConditionalBreakpoints, "supportsConditionalBreakpoints"),
    DAP_FIELD(supportsConfigurationDoneRequest,
              "supportsConfigurationDoneRequest"),
    DAP_FIELD(supportsDataBreakpoints, "supportsDataBreakpoints"),
    DAP_FIELD(supportsDelayedStackTraceLoading,
              "supportsDelayedStackTraceLoading"),
    DAP_FIELD(supportsDisassembleRequest, "supportsDisassembleRequest"),
    DAP_FIELD(supportsEvaluateForHovers, "supportsEvaluateForHovers"),
    DAP_FIELD(supportsExceptionInfoRequest, "supportsExceptionInfoRequest"),
    DAP_FIELD(supportsExceptionOptions, "supportsExceptionOptions"),
    DAP_FIELD(supportsFunctionBreakpoints, "supportsFunctionBreakpoints"),
    DAP_FIELD(supportsGotoTargetsRequest, "supportsGotoTargetsRequest"),
    DAP_FIELD(supportsHitConditionalBreakpoints,
              "supportsHitConditionalBreakpoints"),
    DAP_FIELD(supportsLoadedSourcesRequest, "supportsLoadedSourcesRequest"),
    DAP_FIELD(supportsLogPoints, "supportsLogPoints"),
    DAP_FIELD(supportsModulesRequest, "supportsModulesRequest"),
    DAP_FIELD(supportsReadMemoryRequest, "supportsReadMemoryRequest"),
    DAP_FIELD(supportsRestartFrame, "supportsRestartFrame"),
    DAP_FIELD(supportsRestartRequest, "supportsRestartRequest"),
    DAP_FIELD(supportsSetExpression, "supportsSetExpression"),
    DAP_FIELD(supportsSetVariable, "supportsSetVariable"),
    DAP_FIELD(supportsStepBack, "supportsStepBack"),
    DAP_FIELD(supportsStepInTargetsRequest, "supportsStepInTargetsRequest"),
    DAP_FIELD(supportsTerminateRequest, "supportsTerminateRequest"),
    DAP_FIELD(supportsTerminateThreadsRequest,
              "supportsTerminateThreadsRequest"),
    DAP_FIELD(supportsValueFormattingOptions,
              "supportsValueFormattingOptions"));

// The event indicates that one or more capabilities have changed.
// Since the capabilities are dependent on the frontend and its UI, it might not
// be possible to change that at random times (or too late). Consequently this
// event has a hint characteristic: a frontend can only be expected to make a
// 'best effort' in honouring individual capabilities but there are no
// guarantees. Only changed capabilities need to be included, all other
// capabilities keep their values.
struct CapabilitiesEvent : public Event {
  // The set of updated capabilities.
  Capabilities capabilities;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(CapabilitiesEvent,
                             "capabilities",
                             DAP_FIELD(capabilities, "capabilities"));

// Some predefined types for the CompletionItem. Please note that not all
// clients have specific icons for all of them.
struct CompletionItemType {};

DAP_PROTOCOL_STRUCT_TYPEINFO(CompletionItemType, "");

// CompletionItems are the suggestions returned from the CompletionsRequest.
struct CompletionItem {
  // The label of this completion item. By default this is also the text that is
  // inserted when selecting this completion.
  string label;
  // This value determines how many characters are overwritten by the completion
  // text. If missing the value 0 is assumed which results in the completion
  // text being inserted.
  optional<integer> length;
  // A string that should be used when comparing this item with other items.
  // When `falsy` the label is used.
  optional<string> sortText;
  // This value determines the location (in the CompletionsRequest's 'text'
  // attribute) where the completion text is added. If missing the text is added
  // at the location specified by the CompletionsRequest's 'column' attribute.
  optional<integer> start;
  // If text is not falsy then it is inserted instead of the label.
  optional<string> text;
  // The item's type. Typically the client uses this information to render the
  // item in the UI with an icon.
  optional<CompletionItemType> type;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(CompletionItem,
                             "",
                             DAP_FIELD(label, "label"),
                             DAP_FIELD(length, "length"),
                             DAP_FIELD(sortText, "sortText"),
                             DAP_FIELD(start, "start"),
                             DAP_FIELD(text, "text"),
                             DAP_FIELD(type, "type"));

// Arguments for 'completions' request.
struct CompletionsArguments {
  // The character position for which to determine the completion proposals.
  integer column;
  // Returns completions in the scope of this stack frame. If not specified, the
  // completions are returned for the global scope.
  optional<integer> frameId;
  // An optional line for which to determine the completion proposals. If
  // missing the first line of the text is assumed.
  optional<integer> line;
  // One or more source lines. Typically this is the text a user has typed into
  // the debug console before he asked for completion.
  string text;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(CompletionsArguments,
                             "",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(frameId, "frameId"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(text, "text"));

// Response to 'completions' request.
struct CompletionsResponse : public Response {
  // The possible completions for .
  array<CompletionItem> targets;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(CompletionsResponse,
                             "",
                             DAP_FIELD(targets, "targets"));

// Returns a list of possible completions for a given caret position and text.
// The CompletionsRequest may only be called if the 'supportsCompletionsRequest'
// capability exists and is true.
struct CompletionsRequest : public Request {
  using Response = CompletionsResponse;
  // The character position for which to determine the completion proposals.
  integer column;
  // Returns completions in the scope of this stack frame. If not specified, the
  // completions are returned for the global scope.
  optional<integer> frameId;
  // An optional line for which to determine the completion proposals. If
  // missing the first line of the text is assumed.
  optional<integer> line;
  // One or more source lines. Typically this is the text a user has typed into
  // the debug console before he asked for completion.
  string text;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(CompletionsRequest,
                             "completions",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(frameId, "frameId"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(text, "text"));

// Arguments for 'configurationDone' request.
struct ConfigurationDoneArguments {};

DAP_PROTOCOL_STRUCT_TYPEINFO(ConfigurationDoneArguments, "");

// Response to 'configurationDone' request. This is just an acknowledgement, so
// no body field is required.
struct ConfigurationDoneResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(ConfigurationDoneResponse, "");

// The client of the debug protocol must send this request at the end of the
// sequence of configuration requests (which was started by the 'initialized'
// event).
struct ConfigurationDoneRequest : public Request {
  using Response = ConfigurationDoneResponse;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ConfigurationDoneRequest, "configurationDone");

// Arguments for 'continue' request.
struct ContinueArguments {
  // Continue execution for the specified thread (if possible). If the backend
  // cannot continue on a single thread but will continue on all threads, it
  // should set the 'allThreadsContinued' attribute in the response to true.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ContinueArguments,
                             "",
                             DAP_FIELD(threadId, "threadId"));

// Response to 'continue' request.
struct ContinueResponse : public Response {
  // If true, the 'continue' request has ignored the specified thread and
  // continued all threads instead. If this attribute is missing a value of
  // 'true' is assumed for backward compatibility.
  optional<boolean> allThreadsContinued;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ContinueResponse,
                             "",
                             DAP_FIELD(allThreadsContinued,
                                       "allThreadsContinued"));

// The request starts the debuggee to run again.
struct ContinueRequest : public Request {
  using Response = ContinueResponse;
  // Continue execution for the specified thread (if possible). If the backend
  // cannot continue on a single thread but will continue on all threads, it
  // should set the 'allThreadsContinued' attribute in the response to true.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ContinueRequest,
                             "continue",
                             DAP_FIELD(threadId, "threadId"));

// The event indicates that the execution of the debuggee has continued.
// Please note: a debug adapter is not expected to send this event in response
// to a request that implies that execution continues, e.g. 'launch' or
// 'continue'. It is only necessary to send a 'continued' event if there was no
// previous request that implied this.
struct ContinuedEvent : public Event {
  // If 'allThreadsContinued' is true, a debug adapter can announce that all
  // threads have continued.
  optional<boolean> allThreadsContinued;
  // The thread which was continued.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ContinuedEvent,
                             "continued",
                             DAP_FIELD(allThreadsContinued,
                                       "allThreadsContinued"),
                             DAP_FIELD(threadId, "threadId"));

// This enumeration defines all possible access types for data breakpoints.
struct DataBreakpointAccessType {};

DAP_PROTOCOL_STRUCT_TYPEINFO(DataBreakpointAccessType, "");

// Properties of a data breakpoint passed to the setDataBreakpoints request.
struct DataBreakpoint {
  // The access type of the data.
  optional<DataBreakpointAccessType> accessType;
  // An optional expression for conditional breakpoints.
  optional<string> condition;
  // An id representing the data. This id is returned from the
  // dataBreakpointInfo request.
  string dataId;
  // An optional expression that controls how many hits of the breakpoint are
  // ignored. The backend is expected to interpret the expression as needed.
  optional<string> hitCondition;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(DataBreakpoint,
                             "",
                             DAP_FIELD(accessType, "accessType"),
                             DAP_FIELD(condition, "condition"),
                             DAP_FIELD(dataId, "dataId"),
                             DAP_FIELD(hitCondition, "hitCondition"));

// Arguments for 'dataBreakpointInfo' request.
struct DataBreakpointInfoArguments {
  // The name of the Variable's child to obtain data breakpoint information for.
  // If variableReference isn’t provided, this can be an expression.
  string name;
  // Reference to the Variable container if the data breakpoint is requested for
  // a child of the container.
  optional<integer> variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(DataBreakpointInfoArguments,
                             "",
                             DAP_FIELD(name, "name"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Response to 'dataBreakpointInfo' request.
struct DataBreakpointInfoResponse : public Response {
  // Optional attribute listing the available access types for a potential data
  // breakpoint. A UI frontend could surface this information.
  optional<array<DataBreakpointAccessType>> accessTypes;
  // Optional attribute indicating that a potential data breakpoint could be
  // persisted across sessions.
  optional<boolean> canPersist;
  // An identifier for the data on which a data breakpoint can be registered
  // with the setDataBreakpoints request or null if no data breakpoint is
  // available.
  variant<string, null> dataId;
  // UI string that describes on what data the breakpoint is set on or why a
  // data breakpoint is not available.
  string description;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(DataBreakpointInfoResponse,
                             "",
                             DAP_FIELD(accessTypes, "accessTypes"),
                             DAP_FIELD(canPersist, "canPersist"),
                             DAP_FIELD(dataId, "dataId"),
                             DAP_FIELD(description, "description"));

// Obtains information on a possible data breakpoint that could be set on an
// expression or variable.
struct DataBreakpointInfoRequest : public Request {
  using Response = DataBreakpointInfoResponse;
  // The name of the Variable's child to obtain data breakpoint information for.
  // If variableReference isn’t provided, this can be an expression.
  string name;
  // Reference to the Variable container if the data breakpoint is requested for
  // a child of the container.
  optional<integer> variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(DataBreakpointInfoRequest,
                             "dataBreakpointInfo",
                             DAP_FIELD(name, "name"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Arguments for 'disassemble' request.
struct DisassembleArguments {
  // Number of instructions to disassemble starting at the specified location
  // and offset. An adapter must return exactly this number of instructions -
  // any unavailable instructions should be replaced with an
  // implementation-defined 'invalid instruction' value.
  integer instructionCount;
  // Optional offset (in instructions) to be applied after the byte offset (if
  // any) before disassembling. Can be negative.
  optional<integer> instructionOffset;
  // Memory reference to the base location containing the instructions to
  // disassemble.
  string memoryReference;
  // Optional offset (in bytes) to be applied to the reference location before
  // disassembling. Can be negative.
  optional<integer> offset;
  // If true, the adapter should attempt to resolve memory addresses and other
  // values to symbolic names.
  optional<boolean> resolveSymbols;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(DisassembleArguments,
                             "",
                             DAP_FIELD(instructionCount, "instructionCount"),
                             DAP_FIELD(instructionOffset, "instructionOffset"),
                             DAP_FIELD(memoryReference, "memoryReference"),
                             DAP_FIELD(offset, "offset"),
                             DAP_FIELD(resolveSymbols, "resolveSymbols"));

// Represents a single disassembled instruction.
struct DisassembledInstruction {
  // The address of the instruction. Treated as a hex value if prefixed with
  // '0x', or as a decimal value otherwise.
  string address;
  // The column within the line that corresponds to this instruction, if any.
  optional<integer> column;
  // The end column of the range that corresponds to this instruction, if any.
  optional<integer> endColumn;
  // The end line of the range that corresponds to this instruction, if any.
  optional<integer> endLine;
  // Text representing the instruction and its operands, in an
  // implementation-defined format.
  string instruction;
  // Optional raw bytes representing the instruction and its operands, in an
  // implementation-defined format.
  optional<string> instructionBytes;
  // The line within the source location that corresponds to this instruction,
  // if any.
  optional<integer> line;
  // Source location that corresponds to this instruction, if any. Should always
  // be set (if available) on the first instruction returned, but can be omitted
  // afterwards if this instruction maps to the same source file as the previous
  // instruction.
  optional<Source> location;
  // Name of the symbol that corresponds with the location of this instruction,
  // if any.
  optional<string> symbol;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(DisassembledInstruction,
                             "",
                             DAP_FIELD(address, "address"),
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(endColumn, "endColumn"),
                             DAP_FIELD(endLine, "endLine"),
                             DAP_FIELD(instruction, "instruction"),
                             DAP_FIELD(instructionBytes, "instructionBytes"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(location, "location"),
                             DAP_FIELD(symbol, "symbol"));

// Response to 'disassemble' request.
struct DisassembleResponse : public Response {
  // The list of disassembled instructions.
  array<DisassembledInstruction> instructions;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(DisassembleResponse,
                             "",
                             DAP_FIELD(instructions, "instructions"));

// Disassembles code stored at the provided location.
struct DisassembleRequest : public Request {
  using Response = DisassembleResponse;
  // Number of instructions to disassemble starting at the specified location
  // and offset. An adapter must return exactly this number of instructions -
  // any unavailable instructions should be replaced with an
  // implementation-defined 'invalid instruction' value.
  integer instructionCount;
  // Optional offset (in instructions) to be applied after the byte offset (if
  // any) before disassembling. Can be negative.
  optional<integer> instructionOffset;
  // Memory reference to the base location containing the instructions to
  // disassemble.
  string memoryReference;
  // Optional offset (in bytes) to be applied to the reference location before
  // disassembling. Can be negative.
  optional<integer> offset;
  // If true, the adapter should attempt to resolve memory addresses and other
  // values to symbolic names.
  optional<boolean> resolveSymbols;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(DisassembleRequest,
                             "disassemble",
                             DAP_FIELD(instructionCount, "instructionCount"),
                             DAP_FIELD(instructionOffset, "instructionOffset"),
                             DAP_FIELD(memoryReference, "memoryReference"),
                             DAP_FIELD(offset, "offset"),
                             DAP_FIELD(resolveSymbols, "resolveSymbols"));

// Arguments for 'disconnect' request.
struct DisconnectArguments {
  // A value of true indicates that this 'disconnect' request is part of a
  // restart sequence.
  optional<boolean> restart;
  // Indicates whether the debuggee should be terminated when the debugger is
  // disconnected. If unspecified, the debug adapter is free to do whatever it
  // thinks is best. A client can only rely on this attribute being properly
  // honored if a debug adapter returns true for the 'supportTerminateDebuggee'
  // capability.
  optional<boolean> terminateDebuggee;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(DisconnectArguments,
                             "",
                             DAP_FIELD(restart, "restart"),
                             DAP_FIELD(terminateDebuggee, "terminateDebuggee"));

// Response to 'disconnect' request. This is just an acknowledgement, so no body
// field is required.
struct DisconnectResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(DisconnectResponse, "");

// The 'disconnect' request is sent from the client to the debug adapter in
// order to stop debugging. It asks the debug adapter to disconnect from the
// debuggee and to terminate the debug adapter. If the debuggee has been started
// with the 'launch' request, the 'disconnect' request terminates the debuggee.
// If the 'attach' request was used to connect to the debuggee, 'disconnect'
// does not terminate the debuggee. This behavior can be controlled with the
// 'terminateDebuggee' argument (if supported by the debug adapter).
struct DisconnectRequest : public Request {
  using Response = DisconnectResponse;
  // A value of true indicates that this 'disconnect' request is part of a
  // restart sequence.
  optional<boolean> restart;
  // Indicates whether the debuggee should be terminated when the debugger is
  // disconnected. If unspecified, the debug adapter is free to do whatever it
  // thinks is best. A client can only rely on this attribute being properly
  // honored if a debug adapter returns true for the 'supportTerminateDebuggee'
  // capability.
  optional<boolean> terminateDebuggee;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(DisconnectRequest,
                             "disconnect",
                             DAP_FIELD(restart, "restart"),
                             DAP_FIELD(terminateDebuggee, "terminateDebuggee"));

// A structured message object. Used to return errors from requests.
struct Message {
  // A format string for the message. Embedded variables have the form '{name}'.
  // If variable name starts with an underscore character, the variable does not
  // contain user data (PII) and can be safely used for telemetry purposes.
  string format;
  // Unique identifier for the message.
  integer id;
  // If true send to telemetry.
  optional<boolean> sendTelemetry;
  // If true show user.
  optional<boolean> showUser;
  // An optional url where additional information about this message can be
  // found.
  optional<string> url;
  // An optional label that is presented to the user as the UI for opening the
  // url.
  optional<string> urlLabel;
  // An object used as a dictionary for looking up the variables in the format
  // string.
  optional<map<string, any>> variables;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(Message,
                             "",
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(id, "id"),
                             DAP_FIELD(sendTelemetry, "sendTelemetry"),
                             DAP_FIELD(showUser, "showUser"),
                             DAP_FIELD(url, "url"),
                             DAP_FIELD(urlLabel, "urlLabel"),
                             DAP_FIELD(variables, "variables"));

// On error (whenever 'success' is false), the body can provide more details.
struct ErrorResponse : public Response {
  // An optional, structured error message.
  optional<Message> error;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ErrorResponse, "", DAP_FIELD(error, "error"));

// Provides formatting information for a value.
struct ValueFormat {
  // Display the value in hex.
  optional<boolean> hex;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ValueFormat, "", DAP_FIELD(hex, "hex"));

// Arguments for 'evaluate' request.
struct EvaluateArguments {
  // The context in which the evaluate request is run.
  //
  // May be one of the following enumeration values:
  // 'watch', 'repl', 'hover'
  optional<string> context;
  // The expression to evaluate.
  string expression;
  // Specifies details on how to format the Evaluate result.
  optional<ValueFormat> format;
  // Evaluate the expression in the scope of this stack frame. If not specified,
  // the expression is evaluated in the global scope.
  optional<integer> frameId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(EvaluateArguments,
                             "",
                             DAP_FIELD(context, "context"),
                             DAP_FIELD(expression, "expression"),
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(frameId, "frameId"));

// Optional properties of a variable that can be used to determine how to render
// the variable in the UI.
struct VariablePresentationHint {
  // Set of attributes represented as an array of strings. Before introducing
  // additional values, try to use the listed values.
  optional<array<string>> attributes;
  // The kind of variable. Before introducing additional values, try to use the
  // listed values.
  //
  // May be one of the following enumeration values:
  // 'property', 'method', 'class', 'data', 'event', 'baseClass', 'innerClass',
  // 'interface', 'mostDerivedClass', 'virtual', 'dataBreakpoint'
  optional<string> kind;
  // Visibility of variable. Before introducing additional values, try to use
  // the listed values.
  //
  // May be one of the following enumeration values:
  // 'public', 'private', 'protected', 'internal', 'final'
  optional<string> visibility;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(VariablePresentationHint,
                             "",
                             DAP_FIELD(attributes, "attributes"),
                             DAP_FIELD(kind, "kind"),
                             DAP_FIELD(visibility, "visibility"));

// Response to 'evaluate' request.
struct EvaluateResponse : public Response {
  // The number of indexed child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> indexedVariables;
  // Memory reference to a location appropriate for this result. For pointer
  // type eval results, this is generally a reference to the memory address
  // contained in the pointer.
  optional<string> memoryReference;
  // The number of named child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> namedVariables;
  // Properties of a evaluate result that can be used to determine how to render
  // the result in the UI.
  optional<VariablePresentationHint> presentationHint;
  // The result of the evaluate request.
  string result;
  // The optional type of the evaluate result.
  optional<string> type;
  // If variablesReference is > 0, the evaluate result is structured and its
  // children can be retrieved by passing variablesReference to the
  // VariablesRequest. The value should be less than or equal to 2147483647
  // (2^31 - 1).
  integer variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(EvaluateResponse,
                             "",
                             DAP_FIELD(indexedVariables, "indexedVariables"),
                             DAP_FIELD(memoryReference, "memoryReference"),
                             DAP_FIELD(namedVariables, "namedVariables"),
                             DAP_FIELD(presentationHint, "presentationHint"),
                             DAP_FIELD(result, "result"),
                             DAP_FIELD(type, "type"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Evaluates the given expression in the context of the top most stack frame.
// The expression has access to any variables and arguments that are in scope.
struct EvaluateRequest : public Request {
  using Response = EvaluateResponse;
  // The context in which the evaluate request is run.
  //
  // May be one of the following enumeration values:
  // 'watch', 'repl', 'hover'
  optional<string> context;
  // The expression to evaluate.
  string expression;
  // Specifies details on how to format the Evaluate result.
  optional<ValueFormat> format;
  // Evaluate the expression in the scope of this stack frame. If not specified,
  // the expression is evaluated in the global scope.
  optional<integer> frameId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(EvaluateRequest,
                             "evaluate",
                             DAP_FIELD(context, "context"),
                             DAP_FIELD(expression, "expression"),
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(frameId, "frameId"));

// This enumeration defines all possible conditions when a thrown exception
// should result in a break. never: never breaks, always: always breaks,
// unhandled: breaks when exception unhandled,
// userUnhandled: breaks if the exception is not handled by user code.
struct ExceptionBreakMode {};

DAP_PROTOCOL_STRUCT_TYPEINFO(ExceptionBreakMode, "");

// Detailed information about an exception that has occurred.
struct ExceptionDetails {
  // Optional expression that can be evaluated in the current scope to obtain
  // the exception object.
  optional<string> evaluateName;
  // Fully-qualified type name of the exception object.
  optional<string> fullTypeName;
  // Details of the exception contained by this exception, if any.
  optional<array<ExceptionDetails>> innerException;
  // Message contained in the exception.
  optional<string> message;
  // Stack trace at the time the exception was thrown.
  optional<string> stackTrace;
  // Short type name of the exception object.
  optional<string> typeName;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ExceptionDetails,
                             "",
                             DAP_FIELD(evaluateName, "evaluateName"),
                             DAP_FIELD(fullTypeName, "fullTypeName"),
                             DAP_FIELD(innerException, "innerException"),
                             DAP_FIELD(message, "message"),
                             DAP_FIELD(stackTrace, "stackTrace"),
                             DAP_FIELD(typeName, "typeName"));

// Arguments for 'exceptionInfo' request.
struct ExceptionInfoArguments {
  // Thread for which exception information should be retrieved.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ExceptionInfoArguments,
                             "",
                             DAP_FIELD(threadId, "threadId"));

// Response to 'exceptionInfo' request.
struct ExceptionInfoResponse : public Response {
  // Mode that caused the exception notification to be raised.
  ExceptionBreakMode breakMode;
  // Descriptive text for the exception provided by the debug adapter.
  optional<string> description;
  // Detailed information about the exception.
  optional<ExceptionDetails> details;
  // ID of the exception that was thrown.
  string exceptionId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ExceptionInfoResponse,
                             "",
                             DAP_FIELD(breakMode, "breakMode"),
                             DAP_FIELD(description, "description"),
                             DAP_FIELD(details, "details"),
                             DAP_FIELD(exceptionId, "exceptionId"));

// Retrieves the details of the exception that caused this event to be raised.
struct ExceptionInfoRequest : public Request {
  using Response = ExceptionInfoResponse;
  // Thread for which exception information should be retrieved.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ExceptionInfoRequest,
                             "exceptionInfo",
                             DAP_FIELD(threadId, "threadId"));

// An ExceptionPathSegment represents a segment in a path that is used to match
// leafs or nodes in a tree of exceptions. If a segment consists of more than
// one name, it matches the names provided if 'negate' is false or missing or it
// matches anything except the names provided if 'negate' is true.
struct ExceptionPathSegment {
  // Depending on the value of 'negate' the names that should match or not
  // match.
  array<string> names;
  // If false or missing this segment matches the names provided, otherwise it
  // matches anything except the names provided.
  optional<boolean> negate;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ExceptionPathSegment,
                             "",
                             DAP_FIELD(names, "names"),
                             DAP_FIELD(negate, "negate"));

// An ExceptionOptions assigns configuration options to a set of exceptions.
struct ExceptionOptions {
  // Condition when a thrown exception should result in a break.
  ExceptionBreakMode breakMode;
  // A path that selects a single or multiple exceptions in a tree. If 'path' is
  // missing, the whole tree is selected. By convention the first segment of the
  // path is a category that is used to group exceptions in the UI.
  optional<array<ExceptionPathSegment>> path;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ExceptionOptions,
                             "",
                             DAP_FIELD(breakMode, "breakMode"),
                             DAP_FIELD(path, "path"));

// The event indicates that the debuggee has exited and returns its exit code.
struct ExitedEvent : public Event {
  // The exit code returned from the debuggee.
  integer exitCode;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ExitedEvent,
                             "exited",
                             DAP_FIELD(exitCode, "exitCode"));

// Properties of a breakpoint passed to the setFunctionBreakpoints request.
struct FunctionBreakpoint {
  // An optional expression for conditional breakpoints.
  optional<string> condition;
  // An optional expression that controls how many hits of the breakpoint are
  // ignored. The backend is expected to interpret the expression as needed.
  optional<string> hitCondition;
  // The name of the function.
  string name;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(FunctionBreakpoint,
                             "",
                             DAP_FIELD(condition, "condition"),
                             DAP_FIELD(hitCondition, "hitCondition"),
                             DAP_FIELD(name, "name"));

// Arguments for 'goto' request.
struct GotoArguments {
  // The location where the debuggee will continue to run.
  integer targetId;
  // Set the goto target for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(GotoArguments,
                             "",
                             DAP_FIELD(targetId, "targetId"),
                             DAP_FIELD(threadId, "threadId"));

// Response to 'goto' request. This is just an acknowledgement, so no body field
// is required.
struct GotoResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(GotoResponse, "");

// The request sets the location where the debuggee will continue to run.
// This makes it possible to skip the execution of code or to executed code
// again. The code between the current location and the goto target is not
// executed but skipped. The debug adapter first sends the response and then a
// 'stopped' event with reason 'goto'.
struct GotoRequest : public Request {
  using Response = GotoResponse;
  // The location where the debuggee will continue to run.
  integer targetId;
  // Set the goto target for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(GotoRequest,
                             "goto",
                             DAP_FIELD(targetId, "targetId"),
                             DAP_FIELD(threadId, "threadId"));

// A GotoTarget describes a code location that can be used as a target in the
// 'goto' request. The possible goto targets can be determined via the
// 'gotoTargets' request.
struct GotoTarget {
  // An optional column of the goto target.
  optional<integer> column;
  // An optional end column of the range covered by the goto target.
  optional<integer> endColumn;
  // An optional end line of the range covered by the goto target.
  optional<integer> endLine;
  // Unique identifier for a goto target. This is used in the goto request.
  integer id;
  // Optional memory reference for the instruction pointer value represented by
  // this target.
  optional<string> instructionPointerReference;
  // The name of the goto target (shown in the UI).
  string label;
  // The line of the goto target.
  integer line;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(GotoTarget,
                             "",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(endColumn, "endColumn"),
                             DAP_FIELD(endLine, "endLine"),
                             DAP_FIELD(id, "id"),
                             DAP_FIELD(instructionPointerReference,
                                       "instructionPointerReference"),
                             DAP_FIELD(label, "label"),
                             DAP_FIELD(line, "line"));

// Arguments for 'gotoTargets' request.
struct GotoTargetsArguments {
  // An optional column location for which the goto targets are determined.
  optional<integer> column;
  // The line location for which the goto targets are determined.
  integer line;
  // The source location for which the goto targets are determined.
  Source source;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(GotoTargetsArguments,
                             "",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(source, "source"));

// Response to 'gotoTargets' request.
struct GotoTargetsResponse : public Response {
  // The possible goto targets of the specified location.
  array<GotoTarget> targets;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(GotoTargetsResponse,
                             "",
                             DAP_FIELD(targets, "targets"));

// This request retrieves the possible goto targets for the specified source
// location. These targets can be used in the 'goto' request. The GotoTargets
// request may only be called if the 'supportsGotoTargetsRequest' capability
// exists and is true.
struct GotoTargetsRequest : public Request {
  using Response = GotoTargetsResponse;
  // An optional column location for which the goto targets are determined.
  optional<integer> column;
  // The line location for which the goto targets are determined.
  integer line;
  // The source location for which the goto targets are determined.
  Source source;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(GotoTargetsRequest,
                             "gotoTargets",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(source, "source"));

// Response to 'initialize' request.
struct InitializeResponse : public Response {
  // The set of additional module information exposed by the debug adapter.
  optional<array<ColumnDescriptor>> additionalModuleColumns;
  // The set of characters that should trigger completion in a REPL. If not
  // specified, the UI should assume the '.' character.
  optional<array<string>> completionTriggerCharacters;
  // Available filters or options for the setExceptionBreakpoints request.
  optional<array<ExceptionBreakpointsFilter>> exceptionBreakpointFilters;
  // The debug adapter supports the 'terminateDebuggee' attribute on the
  // 'disconnect' request.
  optional<boolean> supportTerminateDebuggee;
  // Checksum algorithms supported by the debug adapter.
  optional<array<ChecksumAlgorithm>> supportedChecksumAlgorithms;
  // The debug adapter supports the 'breakpointLocations' request.
  optional<boolean> supportsBreakpointLocationsRequest;
  // The debug adapter supports the 'cancel' request.
  optional<boolean> supportsCancelRequest;
  // The debug adapter supports the 'completions' request.
  optional<boolean> supportsCompletionsRequest;
  // The debug adapter supports conditional breakpoints.
  optional<boolean> supportsConditionalBreakpoints;
  // The debug adapter supports the 'configurationDone' request.
  optional<boolean> supportsConfigurationDoneRequest;
  // The debug adapter supports data breakpoints.
  optional<boolean> supportsDataBreakpoints;
  // The debug adapter supports the delayed loading of parts of the stack, which
  // requires that both the 'startFrame' and 'levels' arguments and the
  // 'totalFrames' result of the 'StackTrace' request are supported.
  optional<boolean> supportsDelayedStackTraceLoading;
  // The debug adapter supports the 'disassemble' request.
  optional<boolean> supportsDisassembleRequest;
  // The debug adapter supports a (side effect free) evaluate request for data
  // hovers.
  optional<boolean> supportsEvaluateForHovers;
  // The debug adapter supports the 'exceptionInfo' request.
  optional<boolean> supportsExceptionInfoRequest;
  // The debug adapter supports 'exceptionOptions' on the
  // setExceptionBreakpoints request.
  optional<boolean> supportsExceptionOptions;
  // The debug adapter supports function breakpoints.
  optional<boolean> supportsFunctionBreakpoints;
  // The debug adapter supports the 'gotoTargets' request.
  optional<boolean> supportsGotoTargetsRequest;
  // The debug adapter supports breakpoints that break execution after a
  // specified number of hits.
  optional<boolean> supportsHitConditionalBreakpoints;
  // The debug adapter supports the 'loadedSources' request.
  optional<boolean> supportsLoadedSourcesRequest;
  // The debug adapter supports logpoints by interpreting the 'logMessage'
  // attribute of the SourceBreakpoint.
  optional<boolean> supportsLogPoints;
  // The debug adapter supports the 'modules' request.
  optional<boolean> supportsModulesRequest;
  // The debug adapter supports the 'readMemory' request.
  optional<boolean> supportsReadMemoryRequest;
  // The debug adapter supports restarting a frame.
  optional<boolean> supportsRestartFrame;
  // The debug adapter supports the 'restart' request. In this case a client
  // should not implement 'restart' by terminating and relaunching the adapter
  // but by calling the RestartRequest.
  optional<boolean> supportsRestartRequest;
  // The debug adapter supports the 'setExpression' request.
  optional<boolean> supportsSetExpression;
  // The debug adapter supports setting a variable to a value.
  optional<boolean> supportsSetVariable;
  // The debug adapter supports stepping back via the 'stepBack' and
  // 'reverseContinue' requests.
  optional<boolean> supportsStepBack;
  // The debug adapter supports the 'stepInTargets' request.
  optional<boolean> supportsStepInTargetsRequest;
  // The debug adapter supports the 'terminate' request.
  optional<boolean> supportsTerminateRequest;
  // The debug adapter supports the 'terminateThreads' request.
  optional<boolean> supportsTerminateThreadsRequest;
  // The debug adapter supports a 'format' attribute on the stackTraceRequest,
  // variablesRequest, and evaluateRequest.
  optional<boolean> supportsValueFormattingOptions;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(
    InitializeResponse,
    "",
    DAP_FIELD(additionalModuleColumns, "additionalModuleColumns"),
    DAP_FIELD(completionTriggerCharacters, "completionTriggerCharacters"),
    DAP_FIELD(exceptionBreakpointFilters, "exceptionBreakpointFilters"),
    DAP_FIELD(supportTerminateDebuggee, "supportTerminateDebuggee"),
    DAP_FIELD(supportedChecksumAlgorithms, "supportedChecksumAlgorithms"),
    DAP_FIELD(supportsBreakpointLocationsRequest,
              "supportsBreakpointLocationsRequest"),
    DAP_FIELD(supportsCancelRequest, "supportsCancelRequest"),
    DAP_FIELD(supportsCompletionsRequest, "supportsCompletionsRequest"),
    DAP_FIELD(supportsConditionalBreakpoints, "supportsConditionalBreakpoints"),
    DAP_FIELD(supportsConfigurationDoneRequest,
              "supportsConfigurationDoneRequest"),
    DAP_FIELD(supportsDataBreakpoints, "supportsDataBreakpoints"),
    DAP_FIELD(supportsDelayedStackTraceLoading,
              "supportsDelayedStackTraceLoading"),
    DAP_FIELD(supportsDisassembleRequest, "supportsDisassembleRequest"),
    DAP_FIELD(supportsEvaluateForHovers, "supportsEvaluateForHovers"),
    DAP_FIELD(supportsExceptionInfoRequest, "supportsExceptionInfoRequest"),
    DAP_FIELD(supportsExceptionOptions, "supportsExceptionOptions"),
    DAP_FIELD(supportsFunctionBreakpoints, "supportsFunctionBreakpoints"),
    DAP_FIELD(supportsGotoTargetsRequest, "supportsGotoTargetsRequest"),
    DAP_FIELD(supportsHitConditionalBreakpoints,
              "supportsHitConditionalBreakpoints"),
    DAP_FIELD(supportsLoadedSourcesRequest, "supportsLoadedSourcesRequest"),
    DAP_FIELD(supportsLogPoints, "supportsLogPoints"),
    DAP_FIELD(supportsModulesRequest, "supportsModulesRequest"),
    DAP_FIELD(supportsReadMemoryRequest, "supportsReadMemoryRequest"),
    DAP_FIELD(supportsRestartFrame, "supportsRestartFrame"),
    DAP_FIELD(supportsRestartRequest, "supportsRestartRequest"),
    DAP_FIELD(supportsSetExpression, "supportsSetExpression"),
    DAP_FIELD(supportsSetVariable, "supportsSetVariable"),
    DAP_FIELD(supportsStepBack, "supportsStepBack"),
    DAP_FIELD(supportsStepInTargetsRequest, "supportsStepInTargetsRequest"),
    DAP_FIELD(supportsTerminateRequest, "supportsTerminateRequest"),
    DAP_FIELD(supportsTerminateThreadsRequest,
              "supportsTerminateThreadsRequest"),
    DAP_FIELD(supportsValueFormattingOptions,
              "supportsValueFormattingOptions"));

// The 'initialize' request is sent as the first request from the client to the
// debug adapter in order to configure it with client capabilities and to
// retrieve capabilities from the debug adapter. Until the debug adapter has
// responded to with an 'initialize' response, the client must not send any
// additional requests or events to the debug adapter. In addition the debug
// adapter is not allowed to send any requests or events to the client until it
// has responded with an 'initialize' response. The 'initialize' request may
// only be sent once.
struct InitializeRequest : public Request {
  using Response = InitializeResponse;
  // The ID of the debug adapter.
  string adapterID;
  // The ID of the (frontend) client using this adapter.
  optional<string> clientID;
  // The human readable name of the (frontend) client using this adapter.
  optional<string> clientName;
  // If true all column numbers are 1-based (default).
  optional<boolean> columnsStartAt1;
  // If true all line numbers are 1-based (default).
  optional<boolean> linesStartAt1;
  // The ISO-639 locale of the (frontend) client using this adapter, e.g. en-US
  // or de-CH.
  optional<string> locale;
  // Determines in what format paths are specified. The default is 'path', which
  // is the native format.
  //
  // May be one of the following enumeration values:
  // 'path', 'uri'
  optional<string> pathFormat;
  // Client supports memory references.
  optional<boolean> supportsMemoryReferences;
  // Client supports the runInTerminal request.
  optional<boolean> supportsRunInTerminalRequest;
  // Client supports the paging of variables.
  optional<boolean> supportsVariablePaging;
  // Client supports the optional type attribute for variables.
  optional<boolean> supportsVariableType;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(
    InitializeRequest,
    "initialize",
    DAP_FIELD(adapterID, "adapterID"),
    DAP_FIELD(clientID, "clientID"),
    DAP_FIELD(clientName, "clientName"),
    DAP_FIELD(columnsStartAt1, "columnsStartAt1"),
    DAP_FIELD(linesStartAt1, "linesStartAt1"),
    DAP_FIELD(locale, "locale"),
    DAP_FIELD(pathFormat, "pathFormat"),
    DAP_FIELD(supportsMemoryReferences, "supportsMemoryReferences"),
    DAP_FIELD(supportsRunInTerminalRequest, "supportsRunInTerminalRequest"),
    DAP_FIELD(supportsVariablePaging, "supportsVariablePaging"),
    DAP_FIELD(supportsVariableType, "supportsVariableType"));

// Arguments for 'initialize' request.
struct InitializeRequestArguments {
  // The ID of the debug adapter.
  string adapterID;
  // The ID of the (frontend) client using this adapter.
  optional<string> clientID;
  // The human readable name of the (frontend) client using this adapter.
  optional<string> clientName;
  // If true all column numbers are 1-based (default).
  optional<boolean> columnsStartAt1;
  // If true all line numbers are 1-based (default).
  optional<boolean> linesStartAt1;
  // The ISO-639 locale of the (frontend) client using this adapter, e.g. en-US
  // or de-CH.
  optional<string> locale;
  // Determines in what format paths are specified. The default is 'path', which
  // is the native format.
  //
  // May be one of the following enumeration values:
  // 'path', 'uri'
  optional<string> pathFormat;
  // Client supports memory references.
  optional<boolean> supportsMemoryReferences;
  // Client supports the runInTerminal request.
  optional<boolean> supportsRunInTerminalRequest;
  // Client supports the paging of variables.
  optional<boolean> supportsVariablePaging;
  // Client supports the optional type attribute for variables.
  optional<boolean> supportsVariableType;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(
    InitializeRequestArguments,
    "",
    DAP_FIELD(adapterID, "adapterID"),
    DAP_FIELD(clientID, "clientID"),
    DAP_FIELD(clientName, "clientName"),
    DAP_FIELD(columnsStartAt1, "columnsStartAt1"),
    DAP_FIELD(linesStartAt1, "linesStartAt1"),
    DAP_FIELD(locale, "locale"),
    DAP_FIELD(pathFormat, "pathFormat"),
    DAP_FIELD(supportsMemoryReferences, "supportsMemoryReferences"),
    DAP_FIELD(supportsRunInTerminalRequest, "supportsRunInTerminalRequest"),
    DAP_FIELD(supportsVariablePaging, "supportsVariablePaging"),
    DAP_FIELD(supportsVariableType, "supportsVariableType"));

// This event indicates that the debug adapter is ready to accept configuration
// requests (e.g. SetBreakpointsRequest, SetExceptionBreakpointsRequest). A
// debug adapter is expected to send this event when it is ready to accept
// configuration requests (but not before the 'initialize' request has
// finished). The sequence of events/requests is as follows:
// - adapters sends 'initialized' event (after the 'initialize' request has
// returned)
// - frontend sends zero or more 'setBreakpoints' requests
// - frontend sends one 'setFunctionBreakpoints' request
// - frontend sends a 'setExceptionBreakpoints' request if one or more
// 'exceptionBreakpointFilters' have been defined (or if
// 'supportsConfigurationDoneRequest' is not defined or false)
// - frontend sends other future configuration requests
// - frontend sends one 'configurationDone' request to indicate the end of the
// configuration.
struct InitializedEvent : public Event {};

DAP_PROTOCOL_STRUCT_TYPEINFO(InitializedEvent, "initialized");

// Response to 'launch' request. This is just an acknowledgement, so no body
// field is required.
struct LaunchResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(LaunchResponse, "");

// The launch request is sent from the client to the debug adapter to start the
// debuggee with or without debugging (if 'noDebug' is true). Since launching is
// debugger/runtime specific, the arguments for this request are not part of
// this specification.
struct LaunchRequest : public Request {
  using Response = LaunchResponse;
  // Optional data from the previous, restarted session.
  // The data is sent as the 'restart' attribute of the 'terminated' event.
  // The client should leave the data intact.
  optional<variant<array<any>,
                   boolean,
                   integer,
                   null,
                   number,
                   map<string, any>,
                   string>>
      restart;
  // If noDebug is true the launch request should launch the program without
  // enabling debugging.
  optional<boolean> noDebug;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(LaunchRequest,
                             "launch",
                             DAP_FIELD(restart, "__restart"),
                             DAP_FIELD(noDebug, "noDebug"));

// Arguments for 'launch' request. Additional attributes are implementation
// specific.
struct LaunchRequestArguments {
  // Optional data from the previous, restarted session.
  // The data is sent as the 'restart' attribute of the 'terminated' event.
  // The client should leave the data intact.
  optional<variant<array<any>,
                   boolean,
                   integer,
                   null,
                   number,
                   map<string, any>,
                   string>>
      restart;
  // If noDebug is true the launch request should launch the program without
  // enabling debugging.
  optional<boolean> noDebug;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(LaunchRequestArguments,
                             "",
                             DAP_FIELD(restart, "__restart"),
                             DAP_FIELD(noDebug, "noDebug"));

// The event indicates that some source has been added, changed, or removed from
// the set of all loaded sources.
struct LoadedSourceEvent : public Event {
  // The reason for the event.
  //
  // Must be one of the following enumeration values:
  // 'new', 'changed', 'removed'
  string reason = "new";
  // The new, changed, or removed source.
  Source source;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(LoadedSourceEvent,
                             "loadedSource",
                             DAP_FIELD(reason, "reason"),
                             DAP_FIELD(source, "source"));

// Arguments for 'loadedSources' request.
struct LoadedSourcesArguments {};

DAP_PROTOCOL_STRUCT_TYPEINFO(LoadedSourcesArguments, "");

// Response to 'loadedSources' request.
struct LoadedSourcesResponse : public Response {
  // Set of loaded sources.
  array<Source> sources;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(LoadedSourcesResponse,
                             "",
                             DAP_FIELD(sources, "sources"));

// Retrieves the set of all sources currently loaded by the debugged process.
struct LoadedSourcesRequest : public Request {
  using Response = LoadedSourcesResponse;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(LoadedSourcesRequest, "loadedSources");

// A Module object represents a row in the modules view.
// Two attributes are mandatory: an id identifies a module in the modules view
// and is used in a ModuleEvent for identifying a module for adding, updating or
// deleting. The name is used to minimally render the module in the UI.
//
// Additional attributes can be added to the module. They will show up in the
// module View if they have a corresponding ColumnDescriptor.
//
// To avoid an unnecessary proliferation of additional attributes with similar
// semantics but different names we recommend to re-use attributes from the
// 'recommended' list below first, and only introduce new attributes if nothing
// appropriate could be found.
struct Module {
  // Address range covered by this module.
  optional<string> addressRange;
  // Module created or modified.
  optional<string> dateTimeStamp;
  // Unique identifier for the module.
  variant<integer, string> id;
  // True if the module is optimized.
  optional<boolean> isOptimized;
  // True if the module is considered 'user code' by a debugger that supports
  // 'Just My Code'.
  optional<boolean> isUserCode;
  // A name of the module.
  string name;
  // optional but recommended attributes.
  // always try to use these first before introducing additional attributes.
  //
  // Logical full path to the module. The exact definition is implementation
  // defined, but usually this would be a full path to the on-disk file for the
  // module.
  optional<string> path;
  // Logical full path to the symbol file. The exact definition is
  // implementation defined.
  optional<string> symbolFilePath;
  // User understandable description of if symbols were found for the module
  // (ex: 'Symbols Loaded', 'Symbols not found', etc.
  optional<string> symbolStatus;
  // Version of Module.
  optional<string> version;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(Module,
                             "",
                             DAP_FIELD(addressRange, "addressRange"),
                             DAP_FIELD(dateTimeStamp, "dateTimeStamp"),
                             DAP_FIELD(id, "id"),
                             DAP_FIELD(isOptimized, "isOptimized"),
                             DAP_FIELD(isUserCode, "isUserCode"),
                             DAP_FIELD(name, "name"),
                             DAP_FIELD(path, "path"),
                             DAP_FIELD(symbolFilePath, "symbolFilePath"),
                             DAP_FIELD(symbolStatus, "symbolStatus"),
                             DAP_FIELD(version, "version"));

// The event indicates that some information about a module has changed.
struct ModuleEvent : public Event {
  // The new, changed, or removed module. In case of 'removed' only the module
  // id is used.
  Module module;
  // The reason for the event.
  //
  // Must be one of the following enumeration values:
  // 'new', 'changed', 'removed'
  string reason = "new";
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ModuleEvent,
                             "module",
                             DAP_FIELD(module, "module"),
                             DAP_FIELD(reason, "reason"));

// Arguments for 'modules' request.
struct ModulesArguments {
  // The number of modules to return. If moduleCount is not specified or 0, all
  // modules are returned.
  optional<integer> moduleCount;
  // The index of the first module to return; if omitted modules start at 0.
  optional<integer> startModule;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ModulesArguments,
                             "",
                             DAP_FIELD(moduleCount, "moduleCount"),
                             DAP_FIELD(startModule, "startModule"));

// Response to 'modules' request.
struct ModulesResponse : public Response {
  // All modules or range of modules.
  array<Module> modules;
  // The total number of modules available.
  optional<integer> totalModules;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ModulesResponse,
                             "",
                             DAP_FIELD(modules, "modules"),
                             DAP_FIELD(totalModules, "totalModules"));

// Modules can be retrieved from the debug adapter with the ModulesRequest which
// can either return all modules or a range of modules to support paging.
struct ModulesRequest : public Request {
  using Response = ModulesResponse;
  // The number of modules to return. If moduleCount is not specified or 0, all
  // modules are returned.
  optional<integer> moduleCount;
  // The index of the first module to return; if omitted modules start at 0.
  optional<integer> startModule;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ModulesRequest,
                             "modules",
                             DAP_FIELD(moduleCount, "moduleCount"),
                             DAP_FIELD(startModule, "startModule"));

// The ModulesViewDescriptor is the container for all declarative configuration
// options of a ModuleView. For now it only specifies the columns to be shown in
// the modules view.
struct ModulesViewDescriptor {
  array<ColumnDescriptor> columns;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ModulesViewDescriptor,
                             "",
                             DAP_FIELD(columns, "columns"));

// Arguments for 'next' request.
struct NextArguments {
  // Execute 'next' for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(NextArguments,
                             "",
                             DAP_FIELD(threadId, "threadId"));

// Response to 'next' request. This is just an acknowledgement, so no body field
// is required.
struct NextResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(NextResponse, "");

// The request starts the debuggee to run again for one step.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'step') after the step has completed.
struct NextRequest : public Request {
  using Response = NextResponse;
  // Execute 'next' for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(NextRequest,
                             "next",
                             DAP_FIELD(threadId, "threadId"));

// The event indicates that the target has produced some output.
struct OutputEvent : public Event {
  // The output category. If not specified, 'console' is assumed.
  //
  // May be one of the following enumeration values:
  // 'console', 'stdout', 'stderr', 'telemetry'
  optional<string> category;
  // An optional source location column where the output was produced.
  optional<integer> column;
  // Optional data to report. For the 'telemetry' category the data will be sent
  // to telemetry, for the other categories the data is shown in JSON format.
  optional<variant<array<any>,
                   boolean,
                   integer,
                   null,
                   number,
                   map<string, any>,
                   string>>
      data;
  // An optional source location line where the output was produced.
  optional<integer> line;
  // The output to report.
  string output;
  // An optional source location where the output was produced.
  optional<Source> source;
  // If an attribute 'variablesReference' exists and its value is > 0, the
  // output contains objects which can be retrieved by passing
  // 'variablesReference' to the 'variables' request. The value should be less
  // than or equal to 2147483647 (2^31 - 1).
  optional<integer> variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(OutputEvent,
                             "output",
                             DAP_FIELD(category, "category"),
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(data, "data"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(output, "output"),
                             DAP_FIELD(source, "source"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Arguments for 'pause' request.
struct PauseArguments {
  // Pause execution for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(PauseArguments,
                             "",
                             DAP_FIELD(threadId, "threadId"));

// Response to 'pause' request. This is just an acknowledgement, so no body
// field is required.
struct PauseResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(PauseResponse, "");

// The request suspends the debuggee.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'pause') after the thread has been paused successfully.
struct PauseRequest : public Request {
  using Response = PauseResponse;
  // Pause execution for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(PauseRequest,
                             "pause",
                             DAP_FIELD(threadId, "threadId"));

// The event indicates that the debugger has begun debugging a new process.
// Either one that it has launched, or one that it has attached to.
struct ProcessEvent : public Event {
  // If true, the process is running on the same computer as the debug adapter.
  optional<boolean> isLocalProcess;
  // The logical name of the process. This is usually the full path to process's
  // executable file. Example: /home/example/myproj/program.js.
  string name;
  // The size of a pointer or address for this process, in bits. This value may
  // be used by clients when formatting addresses for display.
  optional<integer> pointerSize;
  // Describes how the debug engine started debugging this process.
  //
  // Must be one of the following enumeration values:
  // 'launch', 'attach', 'attachForSuspendedLaunch'
  optional<string> startMethod;
  // The system process id of the debugged process. This property will be
  // missing for non-system processes.
  optional<integer> systemProcessId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ProcessEvent,
                             "process",
                             DAP_FIELD(isLocalProcess, "isLocalProcess"),
                             DAP_FIELD(name, "name"),
                             DAP_FIELD(pointerSize, "pointerSize"),
                             DAP_FIELD(startMethod, "startMethod"),
                             DAP_FIELD(systemProcessId, "systemProcessId"));

// Arguments for 'readMemory' request.
struct ReadMemoryArguments {
  // Number of bytes to read at the specified location and offset.
  integer count;
  // Memory reference to the base location from which data should be read.
  string memoryReference;
  // Optional offset (in bytes) to be applied to the reference location before
  // reading data. Can be negative.
  optional<integer> offset;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ReadMemoryArguments,
                             "",
                             DAP_FIELD(count, "count"),
                             DAP_FIELD(memoryReference, "memoryReference"),
                             DAP_FIELD(offset, "offset"));

// Response to 'readMemory' request.
struct ReadMemoryResponse : public Response {
  // The address of the first byte of data returned. Treated as a hex value if
  // prefixed with '0x', or as a decimal value otherwise.
  string address;
  // The bytes read from memory, encoded using base64.
  optional<string> data;
  // The number of unreadable bytes encountered after the last successfully read
  // byte. This can be used to determine the number of bytes that must be
  // skipped before a subsequent 'readMemory' request will succeed.
  optional<integer> unreadableBytes;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ReadMemoryResponse,
                             "",
                             DAP_FIELD(address, "address"),
                             DAP_FIELD(data, "data"),
                             DAP_FIELD(unreadableBytes, "unreadableBytes"));

// Reads bytes from memory at the provided location.
struct ReadMemoryRequest : public Request {
  using Response = ReadMemoryResponse;
  // Number of bytes to read at the specified location and offset.
  integer count;
  // Memory reference to the base location from which data should be read.
  string memoryReference;
  // Optional offset (in bytes) to be applied to the reference location before
  // reading data. Can be negative.
  optional<integer> offset;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ReadMemoryRequest,
                             "readMemory",
                             DAP_FIELD(count, "count"),
                             DAP_FIELD(memoryReference, "memoryReference"),
                             DAP_FIELD(offset, "offset"));

// Arguments for 'restart' request.
struct RestartArguments {};

DAP_PROTOCOL_STRUCT_TYPEINFO(RestartArguments, "");

// Arguments for 'restartFrame' request.
struct RestartFrameArguments {
  // Restart this stackframe.
  integer frameId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(RestartFrameArguments,
                             "",
                             DAP_FIELD(frameId, "frameId"));

// Response to 'restartFrame' request. This is just an acknowledgement, so no
// body field is required.
struct RestartFrameResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(RestartFrameResponse, "");

// The request restarts execution of the specified stackframe.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'restart') after the restart has completed.
struct RestartFrameRequest : public Request {
  using Response = RestartFrameResponse;
  // Restart this stackframe.
  integer frameId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(RestartFrameRequest,
                             "restartFrame",
                             DAP_FIELD(frameId, "frameId"));

// Response to 'restart' request. This is just an acknowledgement, so no body
// field is required.
struct RestartResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(RestartResponse, "");

// Restarts a debug session. If the capability 'supportsRestartRequest' is
// missing or has the value false, the client will implement 'restart' by
// terminating the debug adapter first and then launching it anew. A debug
// adapter can override this default behaviour by implementing a restart request
// and setting the capability 'supportsRestartRequest' to true.
struct RestartRequest : public Request {
  using Response = RestartResponse;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(RestartRequest, "restart");

// Arguments for 'reverseContinue' request.
struct ReverseContinueArguments {
  // Execute 'reverseContinue' for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ReverseContinueArguments,
                             "",
                             DAP_FIELD(threadId, "threadId"));

// Response to 'reverseContinue' request. This is just an acknowledgement, so no
// body field is required.
struct ReverseContinueResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(ReverseContinueResponse, "");

// The request starts the debuggee to run backward. Clients should only call
// this request if the capability 'supportsStepBack' is true.
struct ReverseContinueRequest : public Request {
  using Response = ReverseContinueResponse;
  // Execute 'reverseContinue' for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ReverseContinueRequest,
                             "reverseContinue",
                             DAP_FIELD(threadId, "threadId"));

// Response to 'runInTerminal' request.
struct RunInTerminalResponse : public Response {
  // The process ID. The value should be less than or equal to 2147483647 (2^31
  // - 1).
  optional<integer> processId;
  // The process ID of the terminal shell. The value should be less than or
  // equal to 2147483647 (2^31 - 1).
  optional<integer> shellProcessId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(RunInTerminalResponse,
                             "",
                             DAP_FIELD(processId, "processId"),
                             DAP_FIELD(shellProcessId, "shellProcessId"));

// This request is sent from the debug adapter to the client to run a command in
// a terminal. This is typically used to launch the debuggee in a terminal
// provided by the client.
struct RunInTerminalRequest : public Request {
  using Response = RunInTerminalResponse;
  // List of arguments. The first argument is the command to run.
  array<string> args;
  // Working directory of the command.
  string cwd;
  // Environment key-value pairs that are added to or removed from the default
  // environment.
  optional<map<string, any>> env;
  // What kind of terminal to launch.
  //
  // Must be one of the following enumeration values:
  // 'integrated', 'external'
  optional<string> kind;
  // Optional title of the terminal.
  optional<string> title;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(RunInTerminalRequest,
                             "runInTerminal",
                             DAP_FIELD(args, "args"),
                             DAP_FIELD(cwd, "cwd"),
                             DAP_FIELD(env, "env"),
                             DAP_FIELD(kind, "kind"),
                             DAP_FIELD(title, "title"));

// Arguments for 'runInTerminal' request.
struct RunInTerminalRequestArguments {
  // List of arguments. The first argument is the command to run.
  array<string> args;
  // Working directory of the command.
  string cwd;
  // Environment key-value pairs that are added to or removed from the default
  // environment.
  optional<map<string, any>> env;
  // What kind of terminal to launch.
  //
  // Must be one of the following enumeration values:
  // 'integrated', 'external'
  optional<string> kind;
  // Optional title of the terminal.
  optional<string> title;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(RunInTerminalRequestArguments,
                             "",
                             DAP_FIELD(args, "args"),
                             DAP_FIELD(cwd, "cwd"),
                             DAP_FIELD(env, "env"),
                             DAP_FIELD(kind, "kind"),
                             DAP_FIELD(title, "title"));

// A Scope is a named container for variables. Optionally a scope can map to a
// source or a range within a source.
struct Scope {
  // Optional start column of the range covered by this scope.
  optional<integer> column;
  // Optional end column of the range covered by this scope.
  optional<integer> endColumn;
  // Optional end line of the range covered by this scope.
  optional<integer> endLine;
  // If true, the number of variables in this scope is large or expensive to
  // retrieve.
  boolean expensive;
  // The number of indexed variables in this scope.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks.
  optional<integer> indexedVariables;
  // Optional start line of the range covered by this scope.
  optional<integer> line;
  // Name of the scope such as 'Arguments', 'Locals', or 'Registers'. This
  // string is shown in the UI as is and can be translated.
  string name;
  // The number of named variables in this scope.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks.
  optional<integer> namedVariables;
  // An optional hint for how to present this scope in the UI. If this attribute
  // is missing, the scope is shown with a generic UI.
  //
  // May be one of the following enumeration values:
  // 'arguments', 'locals', 'registers'
  optional<string> presentationHint;
  // Optional source for this scope.
  optional<Source> source;
  // The variables of this scope can be retrieved by passing the value of
  // variablesReference to the VariablesRequest.
  integer variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(Scope,
                             "",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(endColumn, "endColumn"),
                             DAP_FIELD(endLine, "endLine"),
                             DAP_FIELD(expensive, "expensive"),
                             DAP_FIELD(indexedVariables, "indexedVariables"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(name, "name"),
                             DAP_FIELD(namedVariables, "namedVariables"),
                             DAP_FIELD(presentationHint, "presentationHint"),
                             DAP_FIELD(source, "source"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Arguments for 'scopes' request.
struct ScopesArguments {
  // Retrieve the scopes for this stackframe.
  integer frameId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ScopesArguments,
                             "",
                             DAP_FIELD(frameId, "frameId"));

// Response to 'scopes' request.
struct ScopesResponse : public Response {
  // The scopes of the stackframe. If the array has length zero, there are no
  // scopes available.
  array<Scope> scopes;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ScopesResponse, "", DAP_FIELD(scopes, "scopes"));

// The request returns the variable scopes for a given stackframe ID.
struct ScopesRequest : public Request {
  using Response = ScopesResponse;
  // Retrieve the scopes for this stackframe.
  integer frameId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ScopesRequest,
                             "scopes",
                             DAP_FIELD(frameId, "frameId"));

// Properties of a breakpoint or logpoint passed to the setBreakpoints request.
struct SourceBreakpoint {
  // An optional source column of the breakpoint.
  optional<integer> column;
  // An optional expression for conditional breakpoints.
  optional<string> condition;
  // An optional expression that controls how many hits of the breakpoint are
  // ignored. The backend is expected to interpret the expression as needed.
  optional<string> hitCondition;
  // The source line of the breakpoint or logpoint.
  integer line;
  // If this attribute exists and is non-empty, the backend must not 'break'
  // (stop) but log the message instead. Expressions within {} are interpolated.
  optional<string> logMessage;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SourceBreakpoint,
                             "",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(condition, "condition"),
                             DAP_FIELD(hitCondition, "hitCondition"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(logMessage, "logMessage"));

// Arguments for 'setBreakpoints' request.
struct SetBreakpointsArguments {
  // The code locations of the breakpoints.
  optional<array<SourceBreakpoint>> breakpoints;
  // Deprecated: The code locations of the breakpoints.
  optional<array<integer>> lines;
  // The source location of the breakpoints; either 'source.path' or
  // 'source.reference' must be specified.
  Source source;
  // A value of true indicates that the underlying source has been modified
  // which results in new breakpoint locations.
  optional<boolean> sourceModified;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetBreakpointsArguments,
                             "",
                             DAP_FIELD(breakpoints, "breakpoints"),
                             DAP_FIELD(lines, "lines"),
                             DAP_FIELD(source, "source"),
                             DAP_FIELD(sourceModified, "sourceModified"));

// Response to 'setBreakpoints' request.
// Returned is information about each breakpoint created by this request.
// This includes the actual code location and whether the breakpoint could be
// verified. The breakpoints returned are in the same order as the elements of
// the 'breakpoints' (or the deprecated 'lines') array in the arguments.
struct SetBreakpointsResponse : public Response {
  // Information about the breakpoints. The array elements are in the same order
  // as the elements of the 'breakpoints' (or the deprecated 'lines') array in
  // the arguments.
  array<Breakpoint> breakpoints;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetBreakpointsResponse,
                             "",
                             DAP_FIELD(breakpoints, "breakpoints"));

// Sets multiple breakpoints for a single source and clears all previous
// breakpoints in that source. To clear all breakpoint for a source, specify an
// empty array. When a breakpoint is hit, a 'stopped' event (with reason
// 'breakpoint') is generated.
struct SetBreakpointsRequest : public Request {
  using Response = SetBreakpointsResponse;
  // The code locations of the breakpoints.
  optional<array<SourceBreakpoint>> breakpoints;
  // Deprecated: The code locations of the breakpoints.
  optional<array<integer>> lines;
  // The source location of the breakpoints; either 'source.path' or
  // 'source.reference' must be specified.
  Source source;
  // A value of true indicates that the underlying source has been modified
  // which results in new breakpoint locations.
  optional<boolean> sourceModified;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetBreakpointsRequest,
                             "setBreakpoints",
                             DAP_FIELD(breakpoints, "breakpoints"),
                             DAP_FIELD(lines, "lines"),
                             DAP_FIELD(source, "source"),
                             DAP_FIELD(sourceModified, "sourceModified"));

// Arguments for 'setDataBreakpoints' request.
struct SetDataBreakpointsArguments {
  // The contents of this array replaces all existing data breakpoints. An empty
  // array clears all data breakpoints.
  array<DataBreakpoint> breakpoints;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetDataBreakpointsArguments,
                             "",
                             DAP_FIELD(breakpoints, "breakpoints"));

// Response to 'setDataBreakpoints' request.
// Returned is information about each breakpoint created by this request.
struct SetDataBreakpointsResponse : public Response {
  // Information about the data breakpoints. The array elements correspond to
  // the elements of the input argument 'breakpoints' array.
  array<Breakpoint> breakpoints;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetDataBreakpointsResponse,
                             "",
                             DAP_FIELD(breakpoints, "breakpoints"));

// Replaces all existing data breakpoints with new data breakpoints.
// To clear all data breakpoints, specify an empty array.
// When a data breakpoint is hit, a 'stopped' event (with reason 'data
// breakpoint') is generated.
struct SetDataBreakpointsRequest : public Request {
  using Response = SetDataBreakpointsResponse;
  // The contents of this array replaces all existing data breakpoints. An empty
  // array clears all data breakpoints.
  array<DataBreakpoint> breakpoints;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetDataBreakpointsRequest,
                             "setDataBreakpoints",
                             DAP_FIELD(breakpoints, "breakpoints"));

// Arguments for 'setExceptionBreakpoints' request.
struct SetExceptionBreakpointsArguments {
  // Configuration options for selected exceptions.
  optional<array<ExceptionOptions>> exceptionOptions;
  // IDs of checked exception options. The set of IDs is returned via the
  // 'exceptionBreakpointFilters' capability.
  array<string> filters;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetExceptionBreakpointsArguments,
                             "",
                             DAP_FIELD(exceptionOptions, "exceptionOptions"),
                             DAP_FIELD(filters, "filters"));

// Response to 'setExceptionBreakpoints' request. This is just an
// acknowledgement, so no body field is required.
struct SetExceptionBreakpointsResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetExceptionBreakpointsResponse, "");

// The request configures the debuggers response to thrown exceptions. If an
// exception is configured to break, a 'stopped' event is fired (with reason
// 'exception').
struct SetExceptionBreakpointsRequest : public Request {
  using Response = SetExceptionBreakpointsResponse;
  // Configuration options for selected exceptions.
  optional<array<ExceptionOptions>> exceptionOptions;
  // IDs of checked exception options. The set of IDs is returned via the
  // 'exceptionBreakpointFilters' capability.
  array<string> filters;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetExceptionBreakpointsRequest,
                             "setExceptionBreakpoints",
                             DAP_FIELD(exceptionOptions, "exceptionOptions"),
                             DAP_FIELD(filters, "filters"));

// Arguments for 'setExpression' request.
struct SetExpressionArguments {
  // The l-value expression to assign to.
  string expression;
  // Specifies how the resulting value should be formatted.
  optional<ValueFormat> format;
  // Evaluate the expressions in the scope of this stack frame. If not
  // specified, the expressions are evaluated in the global scope.
  optional<integer> frameId;
  // The value expression to assign to the l-value expression.
  string value;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetExpressionArguments,
                             "",
                             DAP_FIELD(expression, "expression"),
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(frameId, "frameId"),
                             DAP_FIELD(value, "value"));

// Response to 'setExpression' request.
struct SetExpressionResponse : public Response {
  // The number of indexed child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> indexedVariables;
  // The number of named child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> namedVariables;
  // Properties of a value that can be used to determine how to render the
  // result in the UI.
  optional<VariablePresentationHint> presentationHint;
  // The optional type of the value.
  optional<string> type;
  // The new value of the expression.
  string value;
  // If variablesReference is > 0, the value is structured and its children can
  // be retrieved by passing variablesReference to the VariablesRequest. The
  // value should be less than or equal to 2147483647 (2^31 - 1).
  optional<integer> variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetExpressionResponse,
                             "",
                             DAP_FIELD(indexedVariables, "indexedVariables"),
                             DAP_FIELD(namedVariables, "namedVariables"),
                             DAP_FIELD(presentationHint, "presentationHint"),
                             DAP_FIELD(type, "type"),
                             DAP_FIELD(value, "value"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Evaluates the given 'value' expression and assigns it to the 'expression'
// which must be a modifiable l-value. The expressions have access to any
// variables and arguments that are in scope of the specified frame.
struct SetExpressionRequest : public Request {
  using Response = SetExpressionResponse;
  // The l-value expression to assign to.
  string expression;
  // Specifies how the resulting value should be formatted.
  optional<ValueFormat> format;
  // Evaluate the expressions in the scope of this stack frame. If not
  // specified, the expressions are evaluated in the global scope.
  optional<integer> frameId;
  // The value expression to assign to the l-value expression.
  string value;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetExpressionRequest,
                             "setExpression",
                             DAP_FIELD(expression, "expression"),
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(frameId, "frameId"),
                             DAP_FIELD(value, "value"));

// Arguments for 'setFunctionBreakpoints' request.
struct SetFunctionBreakpointsArguments {
  // The function names of the breakpoints.
  array<FunctionBreakpoint> breakpoints;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetFunctionBreakpointsArguments,
                             "",
                             DAP_FIELD(breakpoints, "breakpoints"));

// Response to 'setFunctionBreakpoints' request.
// Returned is information about each breakpoint created by this request.
struct SetFunctionBreakpointsResponse : public Response {
  // Information about the breakpoints. The array elements correspond to the
  // elements of the 'breakpoints' array.
  array<Breakpoint> breakpoints;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetFunctionBreakpointsResponse,
                             "",
                             DAP_FIELD(breakpoints, "breakpoints"));

// Replaces all existing function breakpoints with new function breakpoints.
// To clear all function breakpoints, specify an empty array.
// When a function breakpoint is hit, a 'stopped' event (with reason 'function
// breakpoint') is generated.
struct SetFunctionBreakpointsRequest : public Request {
  using Response = SetFunctionBreakpointsResponse;
  // The function names of the breakpoints.
  array<FunctionBreakpoint> breakpoints;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetFunctionBreakpointsRequest,
                             "setFunctionBreakpoints",
                             DAP_FIELD(breakpoints, "breakpoints"));

// Arguments for 'setVariable' request.
struct SetVariableArguments {
  // Specifies details on how to format the response value.
  optional<ValueFormat> format;
  // The name of the variable in the container.
  string name;
  // The value of the variable.
  string value;
  // The reference of the variable container.
  integer variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetVariableArguments,
                             "",
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(name, "name"),
                             DAP_FIELD(value, "value"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Response to 'setVariable' request.
struct SetVariableResponse : public Response {
  // The number of indexed child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> indexedVariables;
  // The number of named child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> namedVariables;
  // The type of the new value. Typically shown in the UI when hovering over the
  // value.
  optional<string> type;
  // The new value of the variable.
  string value;
  // If variablesReference is > 0, the new value is structured and its children
  // can be retrieved by passing variablesReference to the VariablesRequest. The
  // value should be less than or equal to 2147483647 (2^31 - 1).
  optional<integer> variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetVariableResponse,
                             "",
                             DAP_FIELD(indexedVariables, "indexedVariables"),
                             DAP_FIELD(namedVariables, "namedVariables"),
                             DAP_FIELD(type, "type"),
                             DAP_FIELD(value, "value"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Set the variable with the given name in the variable container to a new
// value.
struct SetVariableRequest : public Request {
  using Response = SetVariableResponse;
  // Specifies details on how to format the response value.
  optional<ValueFormat> format;
  // The name of the variable in the container.
  string name;
  // The value of the variable.
  string value;
  // The reference of the variable container.
  integer variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SetVariableRequest,
                             "setVariable",
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(name, "name"),
                             DAP_FIELD(value, "value"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Arguments for 'source' request.
struct SourceArguments {
  // Specifies the source content to load. Either source.path or
  // source.sourceReference must be specified.
  optional<Source> source;
  // The reference to the source. This is the same as source.sourceReference.
  // This is provided for backward compatibility since old backends do not
  // understand the 'source' attribute.
  integer sourceReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SourceArguments,
                             "",
                             DAP_FIELD(source, "source"),
                             DAP_FIELD(sourceReference, "sourceReference"));

// Response to 'source' request.
struct SourceResponse : public Response {
  // Content of the source reference.
  string content;
  // Optional content type (mime type) of the source.
  optional<string> mimeType;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SourceResponse,
                             "",
                             DAP_FIELD(content, "content"),
                             DAP_FIELD(mimeType, "mimeType"));

// The request retrieves the source code for a given source reference.
struct SourceRequest : public Request {
  using Response = SourceResponse;
  // Specifies the source content to load. Either source.path or
  // source.sourceReference must be specified.
  optional<Source> source;
  // The reference to the source. This is the same as source.sourceReference.
  // This is provided for backward compatibility since old backends do not
  // understand the 'source' attribute.
  integer sourceReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(SourceRequest,
                             "source",
                             DAP_FIELD(source, "source"),
                             DAP_FIELD(sourceReference, "sourceReference"));

// A Stackframe contains the source location.
struct StackFrame {
  // The column within the line. If source is null or doesn't exist, column is 0
  // and must be ignored.
  integer column;
  // An optional end column of the range covered by the stack frame.
  optional<integer> endColumn;
  // An optional end line of the range covered by the stack frame.
  optional<integer> endLine;
  // An identifier for the stack frame. It must be unique across all threads.
  // This id can be used to retrieve the scopes of the frame with the
  // 'scopesRequest' or to restart the execution of a stackframe.
  integer id;
  // Optional memory reference for the current instruction pointer in this
  // frame.
  optional<string> instructionPointerReference;
  // The line within the file of the frame. If source is null or doesn't exist,
  // line is 0 and must be ignored.
  integer line;
  // The module associated with this frame, if any.
  optional<variant<integer, string>> moduleId;
  // The name of the stack frame, typically a method name.
  string name;
  // An optional hint for how to present this frame in the UI. A value of
  // 'label' can be used to indicate that the frame is an artificial frame that
  // is used as a visual label or separator. A value of 'subtle' can be used to
  // change the appearance of a frame in a 'subtle' way.
  //
  // Must be one of the following enumeration values:
  // 'normal', 'label', 'subtle'
  optional<string> presentationHint;
  // The optional source of the frame.
  optional<Source> source;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StackFrame,
                             "",
                             DAP_FIELD(column, "column"),
                             DAP_FIELD(endColumn, "endColumn"),
                             DAP_FIELD(endLine, "endLine"),
                             DAP_FIELD(id, "id"),
                             DAP_FIELD(instructionPointerReference,
                                       "instructionPointerReference"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(moduleId, "moduleId"),
                             DAP_FIELD(name, "name"),
                             DAP_FIELD(presentationHint, "presentationHint"),
                             DAP_FIELD(source, "source"));

// Provides formatting information for a stack frame.
struct StackFrameFormat : public ValueFormat {
  // Includes all stack frames, including those the debug adapter might
  // otherwise hide.
  optional<boolean> includeAll;
  // Displays the line number of the stack frame.
  optional<boolean> line;
  // Displays the module of the stack frame.
  optional<boolean> module;
  // Displays the names of parameters for the stack frame.
  optional<boolean> parameterNames;
  // Displays the types of parameters for the stack frame.
  optional<boolean> parameterTypes;
  // Displays the values of parameters for the stack frame.
  optional<boolean> parameterValues;
  // Displays parameters for the stack frame.
  optional<boolean> parameters;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StackFrameFormat,
                             "",
                             DAP_FIELD(includeAll, "includeAll"),
                             DAP_FIELD(line, "line"),
                             DAP_FIELD(module, "module"),
                             DAP_FIELD(parameterNames, "parameterNames"),
                             DAP_FIELD(parameterTypes, "parameterTypes"),
                             DAP_FIELD(parameterValues, "parameterValues"),
                             DAP_FIELD(parameters, "parameters"));

// Arguments for 'stackTrace' request.
struct StackTraceArguments {
  // Specifies details on how to format the stack frames.
  optional<StackFrameFormat> format;
  // The maximum number of frames to return. If levels is not specified or 0,
  // all frames are returned.
  optional<integer> levels;
  // The index of the first frame to return; if omitted frames start at 0.
  optional<integer> startFrame;
  // Retrieve the stacktrace for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StackTraceArguments,
                             "",
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(levels, "levels"),
                             DAP_FIELD(startFrame, "startFrame"),
                             DAP_FIELD(threadId, "threadId"));

// Response to 'stackTrace' request.
struct StackTraceResponse : public Response {
  // The frames of the stackframe. If the array has length zero, there are no
  // stackframes available. This means that there is no location information
  // available.
  array<StackFrame> stackFrames;
  // The total number of frames available.
  optional<integer> totalFrames;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StackTraceResponse,
                             "",
                             DAP_FIELD(stackFrames, "stackFrames"),
                             DAP_FIELD(totalFrames, "totalFrames"));

// The request returns a stacktrace from the current execution state.
struct StackTraceRequest : public Request {
  using Response = StackTraceResponse;
  // Specifies details on how to format the stack frames.
  optional<StackFrameFormat> format;
  // The maximum number of frames to return. If levels is not specified or 0,
  // all frames are returned.
  optional<integer> levels;
  // The index of the first frame to return; if omitted frames start at 0.
  optional<integer> startFrame;
  // Retrieve the stacktrace for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StackTraceRequest,
                             "stackTrace",
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(levels, "levels"),
                             DAP_FIELD(startFrame, "startFrame"),
                             DAP_FIELD(threadId, "threadId"));

// Arguments for 'stepBack' request.
struct StepBackArguments {
  // Execute 'stepBack' for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepBackArguments,
                             "",
                             DAP_FIELD(threadId, "threadId"));

// Response to 'stepBack' request. This is just an acknowledgement, so no body
// field is required.
struct StepBackResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepBackResponse, "");

// The request starts the debuggee to run one step backwards.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'step') after the step has completed. Clients should only call this
// request if the capability 'supportsStepBack' is true.
struct StepBackRequest : public Request {
  using Response = StepBackResponse;
  // Execute 'stepBack' for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepBackRequest,
                             "stepBack",
                             DAP_FIELD(threadId, "threadId"));

// Arguments for 'stepIn' request.
struct StepInArguments {
  // Optional id of the target to step into.
  optional<integer> targetId;
  // Execute 'stepIn' for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepInArguments,
                             "",
                             DAP_FIELD(targetId, "targetId"),
                             DAP_FIELD(threadId, "threadId"));

// Response to 'stepIn' request. This is just an acknowledgement, so no body
// field is required.
struct StepInResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepInResponse, "");

// The request starts the debuggee to step into a function/method if possible.
// If it cannot step into a target, 'stepIn' behaves like 'next'.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'step') after the step has completed. If there are multiple
// function/method calls (or other targets) on the source line, the optional
// argument 'targetId' can be used to control into which target the 'stepIn'
// should occur. The list of possible targets for a given source line can be
// retrieved via the 'stepInTargets' request.
struct StepInRequest : public Request {
  using Response = StepInResponse;
  // Optional id of the target to step into.
  optional<integer> targetId;
  // Execute 'stepIn' for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepInRequest,
                             "stepIn",
                             DAP_FIELD(targetId, "targetId"),
                             DAP_FIELD(threadId, "threadId"));

// A StepInTarget can be used in the 'stepIn' request and determines into which
// single target the stepIn request should step.
struct StepInTarget {
  // Unique identifier for a stepIn target.
  integer id;
  // The name of the stepIn target (shown in the UI).
  string label;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepInTarget,
                             "",
                             DAP_FIELD(id, "id"),
                             DAP_FIELD(label, "label"));

// Arguments for 'stepInTargets' request.
struct StepInTargetsArguments {
  // The stack frame for which to retrieve the possible stepIn targets.
  integer frameId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepInTargetsArguments,
                             "",
                             DAP_FIELD(frameId, "frameId"));

// Response to 'stepInTargets' request.
struct StepInTargetsResponse : public Response {
  // The possible stepIn targets of the specified source location.
  array<StepInTarget> targets;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepInTargetsResponse,
                             "",
                             DAP_FIELD(targets, "targets"));

// This request retrieves the possible stepIn targets for the specified stack
// frame. These targets can be used in the 'stepIn' request. The StepInTargets
// may only be called if the 'supportsStepInTargetsRequest' capability exists
// and is true.
struct StepInTargetsRequest : public Request {
  using Response = StepInTargetsResponse;
  // The stack frame for which to retrieve the possible stepIn targets.
  integer frameId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepInTargetsRequest,
                             "stepInTargets",
                             DAP_FIELD(frameId, "frameId"));

// Arguments for 'stepOut' request.
struct StepOutArguments {
  // Execute 'stepOut' for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepOutArguments,
                             "",
                             DAP_FIELD(threadId, "threadId"));

// Response to 'stepOut' request. This is just an acknowledgement, so no body
// field is required.
struct StepOutResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepOutResponse, "");

// The request starts the debuggee to run again for one step.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'step') after the step has completed.
struct StepOutRequest : public Request {
  using Response = StepOutResponse;
  // Execute 'stepOut' for this thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StepOutRequest,
                             "stepOut",
                             DAP_FIELD(threadId, "threadId"));

// The event indicates that the execution of the debuggee has stopped due to
// some condition. This can be caused by a break point previously set, a
// stepping action has completed, by executing a debugger statement etc.
struct StoppedEvent : public Event {
  // If 'allThreadsStopped' is true, a debug adapter can announce that all
  // threads have stopped.
  // - The client should use this information to enable that all threads can be
  // expanded to access their stacktraces.
  // - If the attribute is missing or false, only the thread with the given
  // threadId can be expanded.
  optional<boolean> allThreadsStopped;
  // The full reason for the event, e.g. 'Paused on exception'. This string is
  // shown in the UI as is and must be translated.
  optional<string> description;
  // A value of true hints to the frontend that this event should not change the
  // focus.
  optional<boolean> preserveFocusHint;
  // The reason for the event.
  // For backward compatibility this string is shown in the UI if the
  // 'description' attribute is missing (but it must not be translated).
  //
  // May be one of the following enumeration values:
  // 'step', 'breakpoint', 'exception', 'pause', 'entry', 'goto', 'function
  // breakpoint', 'data breakpoint'
  string reason;
  // Additional information. E.g. if reason is 'exception', text contains the
  // exception name. This string is shown in the UI.
  optional<string> text;
  // The thread which was stopped.
  optional<integer> threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(StoppedEvent,
                             "stopped",
                             DAP_FIELD(allThreadsStopped, "allThreadsStopped"),
                             DAP_FIELD(description, "description"),
                             DAP_FIELD(preserveFocusHint, "preserveFocusHint"),
                             DAP_FIELD(reason, "reason"),
                             DAP_FIELD(text, "text"),
                             DAP_FIELD(threadId, "threadId"));

// Arguments for 'terminate' request.
struct TerminateArguments {
  // A value of true indicates that this 'terminate' request is part of a
  // restart sequence.
  optional<boolean> restart;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(TerminateArguments,
                             "",
                             DAP_FIELD(restart, "restart"));

// Response to 'terminate' request. This is just an acknowledgement, so no body
// field is required.
struct TerminateResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(TerminateResponse, "");

// The 'terminate' request is sent from the client to the debug adapter in order
// to give the debuggee a chance for terminating itself.
struct TerminateRequest : public Request {
  using Response = TerminateResponse;
  // A value of true indicates that this 'terminate' request is part of a
  // restart sequence.
  optional<boolean> restart;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(TerminateRequest,
                             "terminate",
                             DAP_FIELD(restart, "restart"));

// Arguments for 'terminateThreads' request.
struct TerminateThreadsArguments {
  // Ids of threads to be terminated.
  optional<array<integer>> threadIds;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(TerminateThreadsArguments,
                             "",
                             DAP_FIELD(threadIds, "threadIds"));

// Response to 'terminateThreads' request. This is just an acknowledgement, so
// no body field is required.
struct TerminateThreadsResponse : public Response {};

DAP_PROTOCOL_STRUCT_TYPEINFO(TerminateThreadsResponse, "");

// The request terminates the threads with the given ids.
struct TerminateThreadsRequest : public Request {
  using Response = TerminateThreadsResponse;
  // Ids of threads to be terminated.
  optional<array<integer>> threadIds;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(TerminateThreadsRequest,
                             "terminateThreads",
                             DAP_FIELD(threadIds, "threadIds"));

// The event indicates that debugging of the debuggee has terminated. This does
// **not** mean that the debuggee itself has exited.
struct TerminatedEvent : public Event {
  // A debug adapter may set 'restart' to true (or to an arbitrary object) to
  // request that the front end restarts the session. The value is not
  // interpreted by the client and passed unmodified as an attribute '__restart'
  // to the 'launch' and 'attach' requests.
  optional<variant<array<any>,
                   boolean,
                   integer,
                   null,
                   number,
                   map<string, any>,
                   string>>
      restart;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(TerminatedEvent,
                             "terminated",
                             DAP_FIELD(restart, "restart"));

// A Thread
struct Thread {
  // Unique identifier for the thread.
  integer id;
  // A name of the thread.
  string name;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(Thread,
                             "",
                             DAP_FIELD(id, "id"),
                             DAP_FIELD(name, "name"));

// The event indicates that a thread has started or exited.
struct ThreadEvent : public Event {
  // The reason for the event.
  //
  // May be one of the following enumeration values:
  // 'started', 'exited'
  string reason;
  // The identifier of the thread.
  integer threadId;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ThreadEvent,
                             "thread",
                             DAP_FIELD(reason, "reason"),
                             DAP_FIELD(threadId, "threadId"));

// Response to 'threads' request.
struct ThreadsResponse : public Response {
  // All threads.
  array<Thread> threads;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ThreadsResponse,
                             "",
                             DAP_FIELD(threads, "threads"));

// The request retrieves a list of all threads.
struct ThreadsRequest : public Request {
  using Response = ThreadsResponse;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(ThreadsRequest, "threads");

// A Variable is a name/value pair.
// Optionally a variable can have a 'type' that is shown if space permits or
// when hovering over the variable's name. An optional 'kind' is used to render
// additional properties of the variable, e.g. different icons can be used to
// indicate that a variable is public or private. If the value is structured
// (has children), a handle is provided to retrieve the children with the
// VariablesRequest. If the number of named or indexed children is large, the
// numbers should be returned via the optional 'namedVariables' and
// 'indexedVariables' attributes. The client can use this optional information
// to present the children in a paged UI and fetch them in chunks.
struct Variable {
  // Optional evaluatable name of this variable which can be passed to the
  // 'EvaluateRequest' to fetch the variable's value.
  optional<string> evaluateName;
  // The number of indexed child variables.
  // The client can use this optional information to present the children in a
  // paged UI and fetch them in chunks.
  optional<integer> indexedVariables;
  // Optional memory reference for the variable if the variable represents
  // executable code, such as a function pointer.
  optional<string> memoryReference;
  // The variable's name.
  string name;
  // The number of named child variables.
  // The client can use this optional information to present the children in a
  // paged UI and fetch them in chunks.
  optional<integer> namedVariables;
  // Properties of a variable that can be used to determine how to render the
  // variable in the UI.
  optional<VariablePresentationHint> presentationHint;
  // The type of the variable's value. Typically shown in the UI when hovering
  // over the value.
  optional<string> type;
  // The variable's value. This can be a multi-line text, e.g. for a function
  // the body of a function.
  string value;
  // If variablesReference is > 0, the variable is structured and its children
  // can be retrieved by passing variablesReference to the VariablesRequest.
  integer variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(Variable,
                             "",
                             DAP_FIELD(evaluateName, "evaluateName"),
                             DAP_FIELD(indexedVariables, "indexedVariables"),
                             DAP_FIELD(memoryReference, "memoryReference"),
                             DAP_FIELD(name, "name"),
                             DAP_FIELD(namedVariables, "namedVariables"),
                             DAP_FIELD(presentationHint, "presentationHint"),
                             DAP_FIELD(type, "type"),
                             DAP_FIELD(value, "value"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Arguments for 'variables' request.
struct VariablesArguments {
  // The number of variables to return. If count is missing or 0, all variables
  // are returned.
  optional<integer> count;
  // Optional filter to limit the child variables to either named or indexed. If
  // omitted, both types are fetched.
  //
  // Must be one of the following enumeration values:
  // 'indexed', 'named'
  optional<string> filter;
  // Specifies details on how to format the Variable values.
  optional<ValueFormat> format;
  // The index of the first variable to return; if omitted children start at 0.
  optional<integer> start;
  // The Variable reference.
  integer variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(VariablesArguments,
                             "",
                             DAP_FIELD(count, "count"),
                             DAP_FIELD(filter, "filter"),
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(start, "start"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

// Response to 'variables' request.
struct VariablesResponse : public Response {
  // All (or a range) of variables for the given variable reference.
  array<Variable> variables;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(VariablesResponse,
                             "",
                             DAP_FIELD(variables, "variables"));

// Retrieves all child variables for the given variable reference.
// An optional filter can be used to limit the fetched children to either named
// or indexed children.
struct VariablesRequest : public Request {
  using Response = VariablesResponse;
  // The number of variables to return. If count is missing or 0, all variables
  // are returned.
  optional<integer> count;
  // Optional filter to limit the child variables to either named or indexed. If
  // omitted, both types are fetched.
  //
  // Must be one of the following enumeration values:
  // 'indexed', 'named'
  optional<string> filter;
  // Specifies details on how to format the Variable values.
  optional<ValueFormat> format;
  // The index of the first variable to return; if omitted children start at 0.
  optional<integer> start;
  // The Variable reference.
  integer variablesReference;
};

DAP_PROTOCOL_STRUCT_TYPEINFO(VariablesRequest,
                             "variables",
                             DAP_FIELD(count, "count"),
                             DAP_FIELD(filter, "filter"),
                             DAP_FIELD(format, "format"),
                             DAP_FIELD(start, "start"),
                             DAP_FIELD(variablesReference,
                                       "variablesReference"));

}  // namespace dap

#ifdef UNDEF_DAP_PROTOCOL_STRUCT_TYPEINFO
#undef DAP_PROTOCOL_STRUCT_TYPEINFO
#undef UNDEF_DAP_PROTOCOL_STRUCT_TYPEINFO
#endif  // UNDEF_DAP_PROTOCOL_STRUCT_TYPEINFO

#endif  // dap_protocol_h
